<html>
<head>
<title> FIxing AI Multiplayer in SOurce SDK 2013 </title>
</head>
<body>
also search steam forums on how to replace/ or fix the models, so they fire events for firing. CSS type model weapons require some recompiling so they work with hl2 model rig..

https://github.com/bmk10/source-sdk-2013/network/members

https://github.com/whoozzem/SecobMod


http://forums.steampowered.com/forums/showthread.php?t=752399

https://github.com/stephsch/Fixing_AI_In_Multiplayer



http://web.archive.org/web/20110401104700/http://www.moddb.com/company/the-development-team/downloads/hl2mp-sdk-adding-hl2-ai-into-the-hl2mp-sourcesdk

http://www.gamefront.com/files/17687661


http://www.gamefront.com/files/service/thankyou?id=17687661



Implementing AI in HL2MP
------------------------

Requirements.
-------------

This has only been tested with the May 2010 and June 2009 version of the Source SDK HL2MP code.

Working knowledge of Source SDK coding/Visual Studio (or whatever compiler you use).

We will be editing.
-------------------

A ton of files.

Description.
------------

Okay so you've decided not to use the OrangeBox Co-Operative Base Modification (OBCO) patch file, and are wondering why you can't just use the wiki AI patch (which was built from ShadowSource the old name for OBCO). The answer is that this tutorial contains all the fixes (major crash fixes, minor bugs etc) that were included in OBCO but which are not in the AI patch file (which is Winstons' patch converted from the old SDK to the new).

Remember, this code was the work of over 2 years or so of bug fixing on to Winstons AI patch code, that shows how much work went into it.

As always we used #ifdefs which if you keep them (which makes it easier to find the code) then you will have to add it into shareddefs.cpp in the shared folder.

Because of the size of the tutorial there will be very little in the way of information (since the code has comments anyway) it's basically a "replace this, with this" tutorial.

Where possible I have put in code which is already there, so to make it easy to find the lines should the lines listed differ from your own (due to modification).

Credit for the majority of the AI patching goes to Winston, I merely updated it to work on the latest 2007 version and implemented (with his guidance alot of the time) alot of AI fixes.

A final _IMPORTANT_ note is that all references to HL2_EPISODIC should be changed to #ifdef HL2_EPISODIC so that you can easily disable/enable episodic content as required. There is an additional section at the bottom of this AI tutorial telling you changes to make for those wishing to use episodic code. It should be noted that it takes for granted that you have already gone through the code making all refereces to #ifdefs.
 

Implementation.
--------------- 

Remember not to copy and paste in the [(/)quote] tags into your game code ;)

CLIENT FILES
-------------

.\game\client\c_baseentity.cpp

Around about line 80, find the line: static ConVar  cl_interp_npcs( "cl_interp_npcs", "0.0", FCVAR_USERINFO, "Interpolate NPC positions starting this many seconds in past (or cl_interp, if greater)" );  

and replace with the following:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
static ConVar  cl_interp_npcs( "cl_interp_npcs", "0.3", FCVAR_USERINFO, "Interpolate NPC positions starting this many seconds in past (or cl_interp, if greater)" );
#else
static ConVar  cl_interp_npcs( "cl_interp_npcs", "0.0", FCVAR_USERINFO, "Interpolate NPC positions starting this many seconds in past (or cl_interp, if greater)" );  
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\client\c_colorcorrection.cpp

Around about line 124 find the following line: CBaseEntity *pPlayer = UTIL_PlayerByIndex(1);

and replace it with:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = C_BasePlayer::GetLocalPlayer();
#else
CBaseEntity *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\client\fx_impact.cpp

Around line 383, fine the line: C_BaseEntity::EmitSound( filter, NULL, pbulletImpactSoundName, pdata->soundhandles.bulletImpact, &vecOrigin );

and replace it with:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			C_BaseEntity::EmitSound( filter, NULL, pbulletImpactSoundName, /*pdata->soundhandles.bulletImpact,*/ &vecOrigin );
#else
C_BaseEntity::EmitSound( filter, NULL, pbulletImpactSoundName, pdata->soundhandles.bulletImpact, &vecOrigin );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

You Have Now Finished Editing The Required Client Files - Don't forget to save!

SERVER FILES (lots).

.\game\server\ai_basenpc.cpp

In the include lines (around line 90 will do) add the following extra code:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#include "ilagcompensationmanager.h" 

//TDT - Information: Here we include the hl2mp gamerules.
#include "hl2mp_gamerules.h"
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Now line 237 you will find a function: CAI_Manager::CAI_Manager() to which you should add the following code within it:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	m_AIs.EnsureCapacity( MAX_AIS );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 260 or there abouts:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
int CAI_Manager::AddAI( CAI_BaseNPC *pAI ) 
 {
 	m_AIs.AddToTail( pAI );
	return NumAIs()-1; // return the index it was added to 
 }
#else
void CAI_Manager::AddAI( CAI_BaseNPC *pAI )
{
	m_AIs.AddToTail( pAI );
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 657 (approx).

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
/*#ifdef HL2_EPISODIC 
	if ( AI_IsSinglePlayer() ) 
	{
		CBasePlayer *pPlayer = AI_GetSinglePlayer(); 
		if ( pPlayer->IRelationType( this ) != D_LI ) 
		{ 
			CNPC_Alyx *alyx = CNPC_Alyx::GetAlyx(); 

			if ( alyx ) 
			{ 
				alyx->EnemyIgnited( this ); 
			} 
		} 
	} 
#endif*/ 
#else
#ifdef HL2_EPISODIC
	if ( AI_IsSinglePlayer() )
	{
		CBasePlayer *pPlayer = AI_GetSinglePlayer();
		if ( pPlayer->IRelationType( this ) != D_LI )
		{
			CNPC_Alyx *alyx = CNPC_Alyx::GetAlyx();

			if ( alyx )
			{
				alyx->EnemyIgnited( this );
			}
		}
	}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 814 or so:

[quote]
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			if( pAttacker && pAttacker->IsAlive() && UTIL_GetNearestPlayer(GetAbsOrigin()) ) 
#else
if( pAttacker && pAttacker->IsAlive() && pPlayer )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3153 or so:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());  
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer(); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3402:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pLocalPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3606:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3891:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pLocalPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4871:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if( ai_debug_loners.GetBool() && !IsInSquad() ) 
#else
if( ai_debug_loners.GetBool() && !IsInSquad() && AI_IsSinglePlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4882:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		UTIL_GetNearestPlayer(GetAbsOrigin())->GetVectors( NULL, &right, NULL ); 
#else
UTIL_GetLocalPlayer()->GetVectors( NULL, &right, NULL );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 8728:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		info.SetInflictor( (CBaseEntity *)this ); 
#else
info.SetInflictor( ( AI_IsSinglePlayer() ) ? (CBaseEntity *)AI_GetSinglePlayer() : (CBaseEntity *)this );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 9964:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		return UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
return ( CBaseEntity * )AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 9983:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		return UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
return ( CBaseEntity * )AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 10007:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		return UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
return ( CBaseEntity * )AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 11440:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	SetAIIndex( g_AI_Manager.AddAI( this ) ); 
	lagcompensation->RemoveNpcData( GetAIIndex() ); // make sure we're not inheriting anyone else's data 
#else
g_AI_Manager.AddAI( this );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 11471:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	// this should stop a crash occuring when our death immediately creates a new NPC (eg headcrab from zombie) 
	lagcompensation->RemoveNpcData( GetAIIndex() ); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 11994:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				int drop = UTIL_DropToFloor( this, MASK_NPCSOLID, UTIL_GetNearestVisiblePlayer(this) ); 
#else
int drop = UTIL_DropToFloor( this, MASK_NPCSOLID, UTIL_GetLocalPlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 12074:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(pNPC->GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 12604 _AND_ 12610 combined:

[quote]
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		if ( !AI_IsSinglePlayer() ) 
			return false; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI

		// NULL means single player mode
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 12909:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		AI_Waypoint_t *pPathToPoint = GetPathfinder()->BuildRoute( GetAbsOrigin(), vCandidate, UTIL_GetNearestPlayer(GetAbsOrigin()), 5*12, NAV_NONE, true ); 
#else
AI_Waypoint_t *pPathToPoint = GetPathfinder()->BuildRoute( GetAbsOrigin(), vCandidate, AI_GetSinglePlayer(), 5*12, NAV_NONE, true );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 14054:

[quote]
			// Only do this in alyx darkness mode
			#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			if ( HL2MPRules()->IsAlyxInDarknessMode() )
			#else
			if ( HL2GameRules()->IsAlyxInDarknessMode() )
			#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_basenpc.h

Line 449:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#define MAX_AIS	256 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 460:

[quote]
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	int AddAI( CAI_BaseNPC *pAI ); 
#else
void AddAI( CAI_BaseNPC *pAI );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2131:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	// used by lag compensation to be able to refer to & track specific NPCs, and detect changes in the AI list 
	void				SetAIIndex(int i) { m_iAIIndex = i; } 
	int					GetAIIndex() { return m_iAIIndex; } 
private: 
	int					m_iAIIndex; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_basenpc_schedule.cpp

Line 3366:

[quote]
			// Get edict for one player
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3369:

[quote]
						#ifdef OBCO_Enable_Fixed_Multiplayer_AI
							CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
						#else
						CBasePlayer *pPlayer = AI_GetSinglePlayer();
						#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_behavior_fear.cpp

Line 321:

[quote]
	// Here's the distance check:
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	#else
	CBasePlayer *pPlayer = AI_GetSinglePlayer();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 465:

[quote]
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	hintCriteria.AddIncludePosition( UTIL_GetNearestPlayer(GetAbsOrigin())->GetAbsOrigin(), ( ai_fear_player_dist.GetFloat() ) ); 
	#else
	hintCriteria.AddIncludePosition( AI_GetSinglePlayer()->GetAbsOrigin(), ( ai_fear_player_dist.GetFloat() ) );	
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_behavior_follow.cpp

Line 2136:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !pGoalEntity ) 
	{
				CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
		if ( pAI->IRelationType(pPlayer) == D_LI ) 
		{
			pGoalEntity = pPlayer; 
#else
if ( !pGoalEntity && AI_IsSinglePlayer() )
	{
		if ( pAI->IRelationType(UTIL_GetLocalPlayer()) == D_LI )
		{
			pGoalEntity = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_behavior_lead.cpp

Line 150:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( pOuter ) 
	{
		pOuter->SetSpeechTarget( UTIL_GetNearestVisiblePlayer(pOuter) );
#else
if ( pOuter && AI_IsSinglePlayer() )
	{
		pOuter->SetSpeechTarget( UTIL_GetLocalPlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 187:

[quote]
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
 	if ( !AI_GetSinglePlayer() || AI_GetSinglePlayer()->IsDead() ) 
		return false; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 202:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(GetOuter()); 
	if ( !pPlayer ) 
		pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	SetTarget( pPlayer ); 
#else
SetTarget( AI_GetSinglePlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 344:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( GetClosestPointOnRoute( UTIL_GetNearestPlayer(GetAbsOrigin())->GetAbsOrigin(), &vecClosestPoint ) ) 
#else
if ( GetClosestPointOnRoute( AI_GetSinglePlayer()->GetAbsOrigin(), &vecClosestPoint ) )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 376:

[quote]
		// We have to collect data about the person we're leading around.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBaseEntity *pFollower = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBaseEntity *pFollower = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 564:

[quote]
		#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pFollower = UTIL_GetNearestPlayer(GetAbsOrigin()); 
		#else
		CBasePlayer *pFollower = AI_GetSinglePlayer();
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 598:

[quote]
				// We have to collect data about the person we're leading around.
				#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				CBaseEntity *pFollower = UTIL_GetNearestPlayer(GetAbsOrigin()); 
				#else
				CBaseEntity *pFollower = AI_GetSinglePlayer();
				#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 867:

[quote]
		#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			m_MoveMonitor.SetMark( UTIL_GetNearestPlayer(GetAbsOrigin()), 24 ); 
		#else
		m_MoveMonitor.SetMark( AI_GetSinglePlayer(), 24 );
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_behavior_standoff.cpp

Line 719:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		return UTIL_GetNearestPlayer(GetAbsOrigin())->GetAbsOrigin(); 
#else
return UTIL_GetLocalPlayer()->GetAbsOrigin();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 776:

[quote]
				#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
				#else
				CBaseEntity *pPlayer = UTIL_GetLocalPlayer();
				#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1011:

[quote]
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	#else
	CBaseEntity *pPlayer = AI_GetSinglePlayer();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1024:

[quote]
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	#else
	CBaseEntity *pPlayer = AI_GetSinglePlayer();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_hint.cpp

Line 1346:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
		if ( !pPlayer ) 
			UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_planesolver.cpp

Line 353:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBaseEntity *pPlayer = UTIL_GetNearestPlayer(m_pNpc->GetAbsOrigin()); 
#else
CBaseEntity *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_relationship.cpp

Line 194:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( UTIL_GetLocalPlayer() ) 
#else
if ( AI_IsSinglePlayer() && !UTIL_GetLocalPlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_scriptconditions.cpp

Line 476:

[quote]
#ifdef HL2_DLL
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	/*	if( AI_GetSinglePlayer()->GetFlags() & FL_NOTARGET ) 
	{ 
		ScrCondDbgMsg( ("%s WARNING: Player is NOTARGET. This will affect all LOS conditiosn involving the player!\n", GetDebugName()) ); 
	}*/ 
#else
if( AI_GetSinglePlayer()->GetFlags() & FL_NOTARGET )
	{
		ScrCondDbgMsg( ("%s WARNING: Player is NOTARGET. This will affect all LOS conditiosn involving the player!\n", GetDebugName()) );
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
#endif
[/quote]

.\game\server\ai_speech.cpp

Line 326:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetOuter()->GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 937:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(pSpeaker->GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ai_utils.h

Line 26:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
/* 
	if ( gpGlobals->maxClients > 1 ) 
	{ 
		return NULL; 
	} 
	*/ 
#else
if ( gpGlobals->maxClients > 1 )
	{
		return NULL;
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\basecombatcharacter.cpp

Line 1832:

[quote]
				// Figure out how much damage one piece of this type of ammo does to this type of enemy.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI				
float flAmmoDamage = g_pGameRules->GetAmmoDamage( UTIL_GetNearestPlayer(GetAbsOrigin()), this, pWeapon->GetPrimaryAmmoType() ); 
#else
float flAmmoDamage = g_pGameRules->GetAmmoDamage( UTIL_PlayerByIndex(1), this, pWeapon->GetPrimaryAmmoType() );							
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3143:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\baseentity.cpp

Line 798:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	if ( m_debugOverlays & OVERLAY_AUTOAIM_BIT && (GetFlags()&FL_AIMTARGET) && pPlayer != NULL ) 
#else
	if ( m_debugOverlays & OVERLAY_AUTOAIM_BIT && (GetFlags()&FL_AIMTARGET) && AI_GetSinglePlayer() != NULL )	
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 809:

[quote]
		Vector vecRight, vecUp, vecDiag;
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1438:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
			// See which MP player is holding the physics object and then use that player to get the real mass of the object.
			// This is ugly but better than having linkage between an object and its "holding" player.
			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
			{
				CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
				if ( tempPlayer && (tempPlayer->GetHeldObject() == this ) )
				{
				pPlayer = tempPlayer;
					break;
				}
			}
#else
if ( AI_IsSinglePlayer() )
			{
				pPlayer = UTIL_GetLocalPlayer();
			}
			else
			{
				// See which MP player is holding the physics object and then use that player to get the real mass of the object.
				// This is ugly but better than having linkage between an object and its "holding" player.
				for ( int i = 1; i <= gpGlobals->maxClients; i++ )
				{
					CBasePlayer *tempPlayer = UTIL_PlayerByIndex( i );
					if ( tempPlayer && (tempPlayer->GetHeldObject() == this ) )
					{
						pPlayer = tempPlayer;
						break;
					}
				}
			}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 6441:

[quote]
	// Append local player criteria to set,too
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 6512:

[quote]
	// Append local player criteria to set,too
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 6976:

[quote]
	// on Xbox, allow these to fade out
#ifndef _XBOX
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = ( AI_IsSinglePlayer() ) ? UTIL_GetLocalPlayer() : NULL;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\baseflex.cpp

Line 1200:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
						CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2713:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = (CBaseEntity *)UTIL_GetNearestVisiblePlayer(this); 
#else
CBaseEntity *pPlayer = (CBaseEntity *)UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\colorcorrectionvolume.cpp

Line 163:

[quote]
bool CColorCorrectionVolume::PassesTriggerFilters( CBaseEntity *pEntity )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if( pEntity->IsPlayer() ) 
#else
if( pEntity == UTIL_GetLocalPlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\CommentarySystem.cpp

Line 229:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer;

	if ( gpGlobals->maxClients <= 1 )
	{
		pPlayer = UTIL_GetLocalPlayer();
	}
	else
	{
		// only respond to the first player
		pPlayer = UTIL_PlayerByIndex(1);
	}

	return pPlayer;
#else
return UTIL_GetLocalPlayer(); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\effects.cpp

Line 1135:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			player = UTIL_GetNearestVisiblePlayer(this); 
#else
player = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\EntityDissolve.cpp

Line 235:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				CBasePlayer *pPlayer = UTIL_GetLocalPlayer(); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 355:

[quote]
		// passing NULL to TakeDamage causes bad things to happen
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
		#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\entitylist.cpp

Line 566:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			return (CBaseEntity *)UTIL_GetLocalPlayer(); 
#else
return (CBaseEntity *)UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 587:

[quote]
				// FIXME: error condition?
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				return (CBaseEntity *)UTIL_GetLocalPlayer(); 
#else
return (CBaseEntity *)UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 605:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			return FindPickerEntity( UTIL_GetLocalPlayer() ); 
#else
return FindPickerEntity( UTIL_PlayerByIndex(1) );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\EnvHudHint.cpp

Line 79:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 112:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\EnvMessage.cpp

Line 108:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			pPlayer = UTIL_GetLocalPlayer(); // just show it to the host, if there is one 
#else
pPlayer = (gpGlobals->maxClients > 1) ? NULL : UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 226:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CRecipientFilter filter; 
	filter.AddAllPlayers(); 
	filter.MakeReliable(); 
	UserMessageBegin( filter, "CreditsMsg" ); 
#else
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();

	CSingleUserRecipientFilter user( pPlayer );
	user.MakeReliable();

	UserMessageBegin( user, "CreditsMsg" );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 255:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CRecipientFilter filter; 
	filter.AddAllPlayers(); 
	filter.MakeReliable(); 

	// Modification. Set to how old patched AI SDK had code. 
	//CSingleUserRecipientFilter user( pPlayer ); 
	//user.MakeReliable(); 
#else
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();

	CSingleUserRecipientFilter user( pPlayer );
	user.MakeReliable();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 273:

[quote]
	if ( m_flLogoLength )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		UserMessageBegin( filter, "LogoTimeMsg" ); 
#else
UserMessageBegin( user, "LogoTimeMsg" );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 284:

[quote]
	else
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		UserMessageBegin( filter, "CreditsMsg" ); 
#else
UserMessageBegin( user, "CreditsMsg" );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 302:

[quote]
void CCredits::InputRollCredits( inputdata_t &inputdata )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CRecipientFilter filter; 
	filter.AddAllPlayers(); 
	filter.MakeReliable(); 

	UserMessageBegin( filter, "CreditsMsg" ); 
WRITE_BYTE( 2 ); // Modification: Added from old patched AI SDK. 
#else
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();

	CSingleUserRecipientFilter user( pPlayer );
	user.MakeReliable();

	UserMessageBegin( user, "CreditsMsg" );
		WRITE_BYTE( 2 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
	MessageEnd();
[/quote]

.\game\server\env_zoom.cpp

Line 77:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer; 
		
	if ( inputdata.pActivator && inputdata.pActivator->IsPlayer() ) 
		pPlayer = ToBasePlayer( inputdata.pActivator ); 
	else 
		pPlayer= UTIL_GetNearestPlayer(GetAbsOrigin());	 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 117:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer;
	if ( inputdata.pActivator && inputdata.pActivator->IsPlayer() ) 
		pPlayer = ToBasePlayer( inputdata.pActivator ); 
	else 
		pPlayer= UTIL_GetNearestPlayer(GetAbsOrigin());	 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\episodic\vehicle_hl2buggy.cpp

Line 629:

[quote]
	CTakeDamageInfo dmgInfo( pVehicleEntity, pVehicleEntity, damageForce, contactList[i], 200.0f, DMG_CRUSH|DMG_VEHICLE );
			npcList[i]->TakeDamage( dmgInfo );
			
			//TDT - Null Pointers: Occasionally on hitting an AI the game would crash. This is our fix.
			#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			IPhysicsObject*physicsObj = npcList[i]->VPhysicsGetObject();
			if (physicsObj == NULL)
							return;
			#endif //OBCO_Enable_Fixed_Multiplayer_AI
			
			pVehiclePhysics->ApplyForceOffset( vehicleForce, contactList[i] );
[/quote]

.\gamne\server\episodic\vehicle_jeep_episodic.cpp

Line 962:

[quote]
	//Msg("Server detected %d objects\n", m_iNumRadarContacts );

		//TDT - Information: Fix pPlayer from sp to mp.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
#else
		CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI

	CSingleUserRecipientFilter filter(pPlayer);
[/quote]

Line 1141:

[quote]
		Vector vecPlayerForward;
		//TDT - Information: Fix pPlayer from sp to mp.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
		CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
		if ( pPlayer == NULL )
			return NULL;
[/quote]

Line 1328:

[quote]
			npcList[i]->TakeDamage( dmgInfo );
			
			//TDT - Null Pointers: Occasionally on hitting an AI the game would crash. This is our fix.
			#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			IPhysicsObject*physicsObj = npcList[i]->VPhysicsGetObject();
			if (physicsObj == NULL)
							return;
			#endif //OBCO_Enable_Fixed_Multiplayer_AI
			
			pVehiclePhysics->ApplyForceOffset( vehicleForce, contactList[i] );
[/quote]

.\game\server\gameinterface.cpp

Line 1577:

[quote]
		// The safety timer for a dangerous auto save has expired
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetLocalPlayer(); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI

		if ( pPlayer && ( pPlayer->GetDeathTime() == 0.0f || pPlayer->GetDeathTime() > gpGlobals->curtime )
[/quote]

Line 3266:

[quote]
	if ( gpGlobals->maxClients == 1 )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBaseEntity *ent = FindPickerEntity( UTIL_GetLocalPlayer() ); 
#else
CBaseEntity *ent = FindPickerEntity( UTIL_PlayerByIndex(1) );
#endif //OBCO_Enable_Fixed_Multiplayer_AI

		if ( ent )
[/quote]

.\game\server\gameweaponmanager.cpp

Line 244:

[quote]
		if ( gpGlobals->maxClients == 1 )
		{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(pCandidate); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI

			// Nodraw serves as a flag that this weapon is already being removed since
[/quote]

Line 267:

[quote]
			else if ( UTIL_DistApprox( pPlayer->GetAbsOrigin(), pCandidate->GetAbsOrigin() ) > (30*12) )
			{
				fRemovedOne = true;
			}
		}
#ifndef OBCO_Enable_Fixed_Multiplayer_AI	
		else
		{
			fRemovedOne = true;
		}
#endif //OBCO_Enable_Fixed_Multiplayer_AI

		if( fRemovedOne )
[/quote]

.\game\server\genericactor.cpp

Line 450:

[quote]
		else if (flex_talk.GetInt() == -4)
		{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			AddLookTarget( UTIL_GetNearestVisiblePlayer(this), 0.5, flex_looktime.GetFloat()  ); 
#else
AddLookTarget( UTIL_PlayerByIndex( 1 ), 0.5, flex_looktime.GetFloat()  );
#endif //OBCO_Enable_Fixed_Multiplayer_AI

			flex_talk.SetValue( "0" );
[/quote]

.\game\server\gib.cpp

Line 402:

[quote]
			return false;
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = ( AI_IsSinglePlayer() ) ? UTIL_GetLocalPlayer() : NULL;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
	if ( pPlayer && pPlayer->FInViewCone( this ) && m_bForceRemove == false )
	{
[/quote]

.\game\server\hl2\combine_ball.cpp

Line 764:

[quote]
	else
	{
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());  //Slightly different location due to OLD/NEW sdk code differences. Unsure if needed.
	#else
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

.\game\server\hl2\proto_sniper.cpp

Line 842:

[quote]
bool CProtoSniper::IsPlayerAllySniper()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBaseEntity *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1404:

[quote]
//TDT - Information: The condition area below when used in mp caused the sniper to fail terribly. Removing it from working with the AI enabled really improves snipers.
	#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if( !AI_GetSinglePlayer()->IsAlive() && m_bKilledPlayer )
	{
		if( HasCondition(COND_IN_PVS) )
		{
			return SCHED_PSNIPER_PLAYER_DEAD;
		}
	}
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2617:

[quote]
	const int iSearchSize = 32;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pTarget = UTIL_GetNearestVisiblePlayer(this); 
	CBaseEntity *pEntities[ iSearchSize ];

	int iNumEntities = UTIL_EntitiesInSphere( pEntities, iSearchSize, pTarget->GetAbsOrigin(), 180.0f, 0 ); 
#else
CBaseEntity *pTarget = AI_GetSinglePlayer();
	CBaseEntity *pEntities[ iSearchSize ];

	int iNumEntities = UTIL_EntitiesInSphere( pEntities, iSearchSize, AI_GetSinglePlayer()->GetAbsOrigin(), 180.0f, 0 );

#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\script_intro.cpp

Line 236:

[quote]
		// If we weren't blending, then we need to construct a proper starting point from scratch
		#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
		#else
		CBasePlayer *pPlayer = AI_GetSinglePlayer();
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\vehicle_crane.cpp

Line 855:

[quote]
void CPropCrane::InputForcePlayerIn( inputdata_t &inputdata )
{
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	#else
	CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
	#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

.\game\server\hl2\vehicle_prisoner_pod.cpp

Line 598:

[quote]
	if ( pPassenger == NULL )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		// Activator was not a player, just grab the nearest player. 
pPassenger = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
		// Activator was not a player, just grab the singleplayer player.
		pPassenger = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 631:

[quote]
	if ( pPassenger == NULL )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		// Activator was not a player, just grab the nearest player. 
pPassenger = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
// Activator was not a player, just grab the singleplayer player.
		pPassenger = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\vehicle_viewcontroller.cpp

Line 137:

[quote]
void CPropVehicleViewController::InputForcePlayerIn( inputdata_t &inputdata )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2mp\hl2mp_player.cpp

Line 967:

[quote]
		m_iLastWeaponFireUsercmd = m_pCurrentCommand->command_number;
	}
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
bool CHL2MP_Player::WantsLagCompensationOnEntity( const CBaseEntity *pEntity, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const 
{
	// No need to lag compensate at all if we're not attacking in this command and
	// we haven't attacked recently.
	if ( !( pCmd->buttons & IN_ATTACK ) && (pCmd->command_number - m_iLastWeaponFireUsercmd > 5) )
		return false;

	return BaseClass::WantsLagCompensationOnEntity( pEntity, pCmd, pEntityTransmitBits ); 
#else
bool CHL2MP_Player::WantsLagCompensationOnEntity( const CBasePlayer *pPlayer, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const
{
	// No need to lag compensate at all if we're not attacking in this command and
	// we haven't attacked recently.
	if ( !( pCmd->buttons & IN_ATTACK ) && (pCmd->command_number - m_iLastWeaponFireUsercmd > 5) )
		return false;

	return BaseClass::WantsLagCompensationOnEntity( pPlayer, pCmd, pEntityTransmitBits );
#endif //OBCO_Enable_Fixed_Multiplayer_AI

}
[/quote]

Line 1702:

[quote]
if ( !pSpot  )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	char szMapName[256];
	Q_strncpy(szMapName, STRING(gpGlobals->mapname), sizeof(szMapName) );
	Q_strlower(szMapName);

	//TDT - Information: Although we don't support official maps for gaming, they are useful for testing and these maps for whatever reason spawn you in the wrong location. As such this
	// code is here to force players to spawn at the beginning of the selected maps. Custom maps won't require this as they will have deathmatch/class based player starts.
	if( !Q_strnicmp( szMapName, "d1_canals_01a", 13 )
|| !Q_strnicmp( szMapName, "d1_canals_03", 12 )
|| !Q_strnicmp( szMapName, "d1_canals_13", 12 )
|| !Q_strnicmp( szMapName, "d1_town_01", 10 )
|| !Q_strnicmp( szMapName, "d1_town_01a", 11 )
|| !Q_strnicmp( szMapName, "d1_town_02", 10 )
|| !Q_strnicmp( szMapName, "d1_town_02a", 11 )
|| !Q_strnicmp( szMapName, "d1_town_03", 10 )
|| !Q_strnicmp( szMapName, "d1_town_04", 10 )
|| !Q_strnicmp( szMapName, "d1_town_05", 10 )
|| !Q_strnicmp( szMapName, "d2_coast_03", 11)
|| !Q_strnicmp( szMapName, "d2_coast_08", 11 )
|| !Q_strnicmp( szMapName, "d2_coast_11", 11 )
|| !Q_strnicmp( szMapName, "d2_prison_01", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_02", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_03", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_04", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_05", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_06", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_07", 12 )
|| !Q_strnicmp( szMapName, "d2_prison_08", 12 )
|| !Q_strnicmp( szMapName, "d3_c17_08", 9 )
|| !Q_strnicmp( szMapName, "d3_citadel_01", 13 )
|| !Q_strnicmp( szMapName, "d3_citadel_02", 13 )
|| !Q_strnicmp( szMapName, "d3_citadel_03", 13 )
|| !Q_strnicmp( szMapName, "d3_citadel_04", 13 )
|| !Q_strnicmp( szMapName, "d3_citadel_05", 13 )
|| !Q_strnicmp( szMapName, "d3_breen_01", 11 )
|| !Q_strnicmp( szMapName, "ep1_c17_00", 10 )
|| !Q_strnicmp( szMapName, "ep1_c17_00a", 11 )
|| !Q_strnicmp( szMapName, "ep1_c17_02b", 11 )
|| !Q_strnicmp( szMapName, "ep1_c17_05", 10 )
|| !Q_strnicmp( szMapName, "ep2_outland_01a", 15 )
|| !Q_strnicmp( szMapName, "ep2_outland_03", 14 )
|| !Q_strnicmp( szMapName, "ep2_outland_08", 14 )
|| !Q_strnicmp( szMapName, "ep2_outland_06", 14 )
	)
	{
		CBaseEntity *pEntity = NULL;
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
		Vector vecOrigin = pPlayer->GetAbsOrigin();
		pEntity = gEntList.FindEntityByClassnameNearest( "item_suit", vecOrigin, 0, NULL);


		if (pEntity != NULL)
		{
		vecOrigin = pEntity->GetAbsOrigin();
		pEntity = gEntList.FindEntityByClassnameNearest( "info_player_start", vecOrigin, 0, NULL);
		pSpot = pEntity;
		pSpawnpointName = "info_player_start";
		goto ReturnSpot;
		}
		else
		{
		pSpot = gEntList.FindEntityByClassname( pSpot, "info_player_start");
		}
	}
	else if( !Q_strnicmp( szMapName, "d1_trainstation_05", 18 ) )
	{
		CBaseEntity *pEntity = NULL;
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
		Vector vecOrigin = pPlayer->GetAbsOrigin();
		pEntity = gEntList.FindEntityByClassnameNearest( "npc_alyx", vecOrigin, 0, NULL);
		if (pEntity != NULL)
		{
		vecOrigin = pEntity->GetAbsOrigin();
		pEntity = gEntList.FindEntityByClassnameNearest( "info_player_start", vecOrigin, 0, NULL);
		pSpot = pEntity;
		pSpawnpointName = "info_player_start";
		goto ReturnSpot;
		}
		else
		{
		pSpot = gEntList.FindEntityByClassname( pSpot, "info_player_start");
		}
	}
	else
	{
	pSpot = gEntList.FindEntityByClassname( pSpot, "info_player_start");
	}
#else
pSpot = gEntList.FindEntityByClassname( pSpot, "info_player_start");
#endif //OBCO_Enable_Fixed_Multiplayer_AI
}
[/quote]

.\game\server\hl2mp\hl2mp_player.h

Line 216:

[quote]
	virtual int OnTakeDamage( const CTakeDamageInfo &inputInfo );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	virtual bool WantsLagCompensationOnEntity( const CBaseEntity *pPlayer, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const; 
#else
	virtual bool WantsLagCompensationOnEntity( const CBasePlayer *pPlayer, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\ai_allymanager.cpp

Line 127:

[quote]
	(*pTotal) = (*pMedics) = 0;

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#else
	if ( !AI_IsSinglePlayer() ) 
	{
		// @TODO (toml 10-22-04): no MP support right now
		return;
	}

	const Vector &	vPlayerPos = UTIL_GetLocalPlayer()->GetAbsOrigin();

#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 154:

[quote]
			// They only count if I can use them.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			if( ppAIs[i]->IRelationType( UTIL_GetNearestPlayer(ppAIs[i]->GetAbsOrigin()) ) != D_LI )
#else
if( ppAIs[i]->IRelationType( UTIL_GetLocalPlayer() ) != D_LI )
#endif //OBCO_Enable_Fixed_Multiplayer_AI				
continue;
[/quote]

Line 162:

[quote]
	// Skip distant NPCs
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			Vector vNearestPlayerPos = UTIL_GetNearestPlayer(ppAIs[i]->GetAbsOrigin())->GetAbsOrigin();
			if ( !ppAIs[i]->IsInPlayerSquad() && 
				!UTIL_FindClientInPVS( ppAIs[i]->edict() ) && 
				( ( ppAIs[i]->GetAbsOrigin() - vNearestPlayerPos ).LengthSqr() > 150*12 ||
				  fabsf( ppAIs[i]->GetAbsOrigin().z - vNearestPlayerPos.z ) > 192 ) )
#else
			if ( !ppAIs[i]->IsInPlayerSquad() && 
				!UTIL_FindClientInPVS( ppAIs[i]->edict() ) && 
				( ( ppAIs[i]->GetAbsOrigin() - vPlayerPos ).LengthSqr() > 150*12 ||
				  fabsf( ppAIs[i]->GetAbsOrigin().z - vPlayerPos.z ) > 192 ) )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
				continue;
[/quote]

.\game\server\hl2\ai_behavior_actbusy.cpp

Line 505:

[quote]
	Assert( IsCombatActBusy() );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 554:

[quote]
	Assert( IsCombatActBusy() );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 850:

[quote]
					ClearCondition( COND_NEW_ENEMY );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1183:

[quote]
			if( IsCombatActBusy() )
			{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(GetOuter()); 
				if ( m_hActBusyGoal->IsCombatActBusyTeleportAllowed() && m_iNumConsecutivePathFailures >= 2 && !pPlayer->FInViewCone(GetOuter()) )  
#else
if ( m_hActBusyGoal->IsCombatActBusyTeleportAllowed() && m_iNumConsecutivePathFailures >= 2 && !AI_GetSinglePlayer()->FInViewCone(GetOuter()) )
#endif //OBCO_Enable_Fixed_Multiplayer_AI		
[/quote]

.\game\server\hl2\

Line 1175:

[quote]
	SetContextThink( &CAntlionTemplateMaker::FindNodesCloseToPlayer, gpGlobals->curtime + random->RandomFloat( 0.75, 1.75 ), s_pBlockedEffectsThinkContext );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); // dubious 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1266:

[quote]
				Vector vHintPos;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				pNode->GetPosition( UTIL_GetNearestPlayer(GetAbsOrigin()), &vHintPos ); 
#else
pNode->GetPosition( AI_GetSinglePlayer(), &vHintPos );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\combine_mine.cpp

Line 876:

[quote]
	// finally, check the player.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 886:

[quote]
		float flDist = (pPlayer->GetAbsOrigin() - GetAbsOrigin() ).LengthSqr();

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if( flDist < flNearest ) 
#else
if( flDist < flNearest && FVisible( pPlayer, MASK_SOLID_BRUSHONLY ) )
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

.\game\server\hl2\env_headcrabcanister.cpp

Line 928:

[quote]
	// Shake the screen unless flagged otherwise
	if ( !HasSpawnFlags( SF_NO_SHAKE ) )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\func_tank.cpp

Line 1561:

[quote]
#ifdef FUNCTANK_AUTOUSE

	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2263:

[quote]
		if ( IsX360() )
		{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			UTIL_GetNearestPlayer(GetAbsOrigin())->RumbleEffect( RUMBLE_AR2, 0, RUMBLE_FLAG_RESTART | RUMBLE_FLAG_RANDOM_AMPLITUDE ); 
#else
UTIL_PlayerByIndex(1)->RumbleEffect( RUMBLE_AR2, 0, RUMBLE_FLAG_RESTART | RUMBLE_FLAG_RANDOM_AMPLITUDE );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3517:

[quote]
void UTIL_VisualizeCurve( int type, int steps, float bias )
{
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4255:

[quote]
			Vector vecTargetPosition = GetTargetPosition();
			#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4429:

[quote]
	// If the shot passed near the player, shake the screen.
	//TDT - Information: Updated for multiplayer.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	
		CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this);
		if ( pPlayer == NULL)
		{
		return;
		}
		Vector vecPlayer = pPlayer->EyePosition();
#else
	if( AI_IsSinglePlayer() )
	{
		Vector vecPlayer = AI_GetSinglePlayer()->EyePosition();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4452:

[quote]
			UTIL_ScreenShake( vecNearestPoint, 10, 60, 0.3, 120.0f, SHAKE_START, false );
		}
	#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	}
	#endif //OBCO_Enable_Fixed_Multiplayer_AI

[/quote]

.\game\server\hl2\hl2_player.cpp

Line 2537:

[quote]
	BaseClass::Event_Killed( info );

	//TDT - CodeAddendumms: Fix by TheRealJMan.
	#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	FirePlayerProxyOutput( "PlayerDied", variant_t(), this, this );
	NotifyScriptsOfDeath();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\item_dynamic_resupply.cpp

Line 294:

[quote]
void CItem_DynamicResupply::InputCalculateType( inputdata_t &data )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	// spawn gear for the nearest player 
	CBasePlayer *pNearest = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	if ( pNearest != NULL ) 
		SpawnDynamicItem( pNearest ); 
#else
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
	SpawnDynamicItem( pPlayer );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_antlion.cpp

Line 4025:

[quote]
	//See if the touching entity is a vehicle
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *pPlayer = ToBasePlayer( AI_GetSinglePlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4031:

[quote]
// FIXME: Technically we'll want to check to see if a vehicle has touched us with the player OR NPC driver

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	for (int i = 1; i <= gpGlobals->maxClients; i++ ) 
	{
	CBasePlayer *pPlayer = UTIL_PlayerByIndex( i ); 
		if ( !pPlayer || !pPlayer->IsInAVehicle() ) 
			continue; 
#else
if ( pPlayer && pPlayer->IsInAVehicle() )
	{
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4090:

[quote]
				CSoundEnt::InsertSound( SOUND_PHYSICS_DANGER, GetAbsOrigin(), 256, 0.5f, this );
					}
				}
			}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			break; // safe to assume will only be touched by 1 vehicle per frame 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
		}
[/quote]

.\game\server\hl2\npc_antlionguard.cpp

Line 1607:

[quote]
void CNPC_AntlionGuard::Footstep( bool bHeavy )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
#else
	CBasePlayer *pPlayer = AI_GetSinglePlayer();
	Assert( pPlayer != NULL );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_attackchopper.cpp

Line 5567:

[quote]
	// if player is the owner and we're set to explode on contact, then the player threw this grenade.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
//TDT - CodeAddendumms: Fix by TheRealJMan.
return ( m_bExplodeOnContact ); 
#else
return ( ( GetOwnerEntity() == UTIL_GetLocalPlayer() ) && m_bExplodeOnContact );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_basescanner.cpp

Line 1297:

[quote]
	pPhysicsObject->GetVelocity( &vecVelocity, NULL );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

.\game\server\hl2\npc_citizen17.cpp

Line 215:

[quote]
					pAllyNpc->AddSpawnFlags(SF_NPC_GAG);
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					pAllyNpc->TargetOrder( UTIL_GetNearestPlayer(pAllyNpc->GetAbsOrigin()), &pAllyNpc, 1 ); 
#else
pAllyNpc->TargetOrder( UTIL_GetLocalPlayer(), &pAllyNpc, 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 555:

[quote]
	else
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if ( ( m_spawnflags & SF_CITIZEN_FOLLOW ) ) 
		{
			m_FollowBehavior.SetFollowTarget( UTIL_GetNearestPlayer(GetAbsOrigin()) );
#else
if ( ( m_spawnflags & SF_CITIZEN_FOLLOW ) && AI_IsSinglePlayer() )
		{
			m_FollowBehavior.SetFollowTarget( UTIL_GetLocalPlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 911:

[quote]
		// Leave the player squad if someone has made me neutral to player.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if( IRelationType(UTIL_GetNearestPlayer(GetAbsOrigin())) == D_NU ) 
#else
if( IRelationType(UTIL_GetLocalPlayer()) == D_NU )
#endif //OBCO_Enable_Fixed_Multiplayer_AI		
[/quote]

Line 949:

[quote]
	if( CanHeal() )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this);
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1007:

[quote]
void CNPC_Citizen::PredictPlayerPush()
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !AI_IsSinglePlayer() )
		return;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1019:

[quote]
	BaseClass::PredictPlayerPush();

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1470:

[quote]
int CNPC_Citizen::TranslateSchedule( int scheduleType ) 
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pLocalPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1488:

[quote]
			if( flDist < 50 * 12 )
			{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
			AddSpawnFlags( SF_CITIZEN_NOT_COMMANDABLE );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1529:

[quote]
					return SCHED_STANDOFF;
				}
			}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			else if ( GetEnemy() ) 
			{
				CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetEnemy()->GetAbsOrigin()); 
				if ( pPlayer && ( ( GetEnemy()->GetAbsOrigin() -  
#else
else
			{
				CBasePlayer *pPlayer = AI_GetSinglePlayer();
				if ( pPlayer && GetEnemy() && ( ( GetEnemy()->GetAbsOrigin() - 
#endif //OBCO_Enable_Fixed_Multiplayer_AI

[/quote]

Line 1813:

[quote]
					Vector vecEnemyPos = GetEnemy()->BodyTarget(GetAbsOrigin(), false);
					
					#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetEnemy()->GetAbsOrigin()); 
					#else
					CBasePlayer *pPlayer = AI_GetSinglePlayer();
					#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 2369:

[quote]
bool CNPC_Citizen::CanJoinPlayerSquad()
{
	#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !AI_IsSinglePlayer() )
		return false;
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2387:

[quote]
	// Don't bother people who don't want to be bothered
	if ( !CanBeUsedAsAFriend() )
		return false;

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( IRelationType( UTIL_GetNearestPlayer(GetAbsOrigin()) ) != D_LI ) 
#else
if ( IRelationType( UTIL_GetLocalPlayer() ) != D_LI )
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 2419:

[quote]
bool CNPC_Citizen::IsCommandMoving()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if ( IsInPlayerSquad() ) 
	{
		if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetNearestPlayer(GetAbsOrigin()) || 
#else
if ( AI_IsSinglePlayer() && IsInPlayerSquad() )
	{
		if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetLocalPlayer() ||
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 2441:

[quote]
bool CNPC_Citizen::ShouldAutoSummon()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !IsFollowingCommandPoint() || !IsInPlayerSquad() ) 
		return false;

	CHL2_Player *pPlayer = (CHL2_Player *)UTIL_GetNearestPlayer(GetAbsOrigin());
#else
if ( !AI_IsSinglePlayer() || !IsFollowingCommandPoint() || !IsInPlayerSquad() )
		return false;

	CHL2_Player *pPlayer = (CHL2_Player *)UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2579:

[quote]
									( GetSquad() ) ? GetSquad()->NumMembers() : 1,
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
									ShouldSpeakRadio( UTIL_GetNearestPlayer(GetAbsOrigin()) ), 
#else
ShouldSpeakRadio( AI_GetSinglePlayer() ),
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2627:

[quote]
void CNPC_Citizen::MoveOrder( const Vector &vecDest, CAI_BaseNPC **Allies, int numAllies )
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		if ( !AI_IsSinglePlayer() ) 
		return; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2638:

[quote]
		SpeakCommandResponse( STRING(m_iszDenyCommandConcept) );
		return;
	}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
CHL2_Player *pPlayer = (CHL2_Player *)UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CHL2_Player *pPlayer = (CHL2_Player *)UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2728:

[quote]
	// Robin: NPCs should always respond to +USE even if someone else has the semaphore.

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !CanJoinPlayerSquad() )
#else
if ( !AI_IsSinglePlayer() || !CanJoinPlayerSquad() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2738:

[quote]
		SimpleUse( pActivator, pCaller, useType, value );
		return;
	}
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( pActivator == UTIL_GetNearestPlayer(GetAbsOrigin()) )
#else
if ( pActivator == UTIL_GetLocalPlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2845:

[quote]
void CNPC_Citizen::TogglePlayerSquadState()
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
if ( !AI_IsSinglePlayer() )
		return;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2858:

[quote]
			SpeakCommandResponse( TLK_COMMANDED );
		}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		else if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetNearestPlayer(GetAbsOrigin()) ) 
#else
else if ( m_FollowBehavior.GetFollowTarget() == UTIL_GetLocalPlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 2888:

[quote]
void CNPC_Citizen::UpdatePlayerSquad()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	if ( pPlayer && ( pPlayer->GetAbsOrigin().AsVector2D() - GetAbsOrigin().AsVector2D() ).LengthSqr() < Square(20*12) ) 
#else
	if ( !AI_IsSinglePlayer() )
		return;

	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
	if ( ( pPlayer->GetAbsOrigin().AsVector2D() - GetAbsOrigin().AsVector2D() ).LengthSqr() < Square(20*12) )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3176:

[quote]
void CNPC_Citizen::FixupPlayerSquad()
{

#ifndef OBCO_Enable_Fixed_Multiplayer_AI
if ( !AI_IsSinglePlayer() )
		return;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3248:

[quote]
void CNPC_Citizen::ClearFollowTarget()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	m_FollowBehavior.SetFollowTarget( UTIL_GetNearestPlayer(GetAbsOrigin()) ); 
#else
m_FollowBehavior.SetFollowTarget( NULL );
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 3261:

[quote]
void CNPC_Citizen::UpdateFollowCommandPoint()
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
if ( !AI_IsSinglePlayer() )
		return;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3296:

[quote]
				ClearFollowTarget();

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pNearest = UTIL_GetNearestPlayer(GetAbsOrigin()); 
			if ( m_FollowBehavior.GetFollowTarget() != pNearest ) 
			{
				DevMsg( "Switching to following new nearest player\n" );
				m_FollowBehavior.SetFollowTarget( pNearest );
#else
if ( m_FollowBehavior.GetFollowTarget() != UTIL_GetLocalPlayer() )
			{
				DevMsg( "Expected to be following player, but not\n" );
				m_FollowBehavior.SetFollowTarget( UTIL_GetLocalPlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3352:

[quote]
CAI_BaseNPC *CNPC_Citizen::GetSquadCommandRepresentative()
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !AI_IsSinglePlayer() )
	return NULL;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3369:

[quote]
			CUtlVectorFixed<SquadMemberInfo_t, MAX_SQUAD_MEMBERS> candidates;

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3859:

[quote]
void	CNPC_Citizen::InputForceHealthKitToss( inputdata_t &inputdata )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	TossHealthKit( UTIL_GetNearestPlayer(GetAbsOrigin()), Vector(48.0f, 0.0f, 0.0f)  ); 
#else
TossHealthKit( UTIL_GetLocalPlayer(), Vector(48.0f, 0.0f, 0.0f)  );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3886:

[quote]
	// Player is hurt, don't steal his health.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pNearest = UTIL_GetNearestVisiblePlayer(this); 
	if( pNearest && pNearest->GetHealth() <= pNearest->GetMaxHealth() * 0.75f ) 
#else
if( AI_IsSinglePlayer() && UTIL_GetLocalPlayer()->GetHealth() <= UTIL_GetLocalPlayer()->GetHealth() * 0.75f )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4276:

[quote]
	bool bStayActive = false;
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if ( AI_IsSinglePlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4295:

[quote]
					CBaseEntity *pCitizen = NULL;
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4301:

[quote]
					while ( (pCitizen = gEntList.FindEntityByClassname( pCitizen, "npc_citizen" ) ) != NULL)
					{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					CBasePlayer *pPlayer = UTIL_GetNearestPlayer(pCitizen->GetAbsOrigin()); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

.\game\server\hl2\npc_combine.cpp

Line 759:

[quote]
		if( IsInSquad() && GetSquad()->NumMembers() > 1 )
		{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_combinedropship.cpp

Line 1549:

[quote]
	float flNearFactor = 0.0f; 
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBaseEntity *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_combinegunship.cpp

Line 2375:

[quote]
	// Apply the pitch to both sounds. 
	controller.SoundChangePitch( m_pAirExhaustSound, iPitch, 0.1 );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
// FIXME: Doesn't work in multiplayer
	CBaseEntity *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_dog.cpp

Line 343:

[quote]
		physfollower_t *pBone;
		int i;

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pLocalPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 840:

[quote]
			if ( m_hThrowTarget == NULL )
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				  m_hThrowTarget = UTIL_GetNearestVisiblePlayer(this); 
#else
m_hThrowTarget = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1398:

[quote]
				SetAim( m_hPhysicsEnt->WorldSpaceCenter() - GetAbsOrigin() );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1536:

[quote]
	if ( m_hThrowTarget == NULL )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		m_hThrowTarget = UTIL_GetNearestVisiblePlayer(this); 
#else
m_hThrowTarget = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1696:

[quote]
		if ( m_hThrowTarget == NULL )
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			m_hThrowTarget = UTIL_GetNearestVisiblePlayer(this); 
#else
	m_hThrowTarget = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_enemyfinder.cpp

Line 347:

[quote]
	BaseClass::StartNPC();

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( m_PlayerFreePass.GetParams().duration > 0.1 ) 
	{
		m_PlayerFreePass.SetPassTarget( UTIL_GetNearestPlayer(GetAbsOrigin()) ); 
#else
if ( AI_IsSinglePlayer() && m_PlayerFreePass.GetParams().duration > 0.1 )
	{
		m_PlayerFreePass.SetPassTarget( UTIL_PlayerByIndex(1) );
#endif //OBCO_Enable_Fixed_Multiplayer_AI

[/quote]

Line 425:

[quote]
	if ( BaseClass::ShouldAlwaysThink() )
		return true;
		
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_headcrab.cpp

Line 1326:

[quote]
					SetSchedule( SCHED_HEADCRAB_CEILING_DROP );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBaseEntity *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_metropolice.cpp

Line 500:

[quote]
	if ( PlayerIsCriminal() == false )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 3907:

[quote]
void CNPC_MetroPolice::IncrementPlayerCriminalStatus( void )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3964:

[quote]
void CNPC_MetroPolice::AdministerJustice( void )
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !AI_IsSinglePlayer() ) 
		return; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3980:

[quote]
		// Attack the target
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
		if ( !pPlayer ) 
			pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 4011:

[quote]
					// Is he within site & range?
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
					if ( pPlayer && FVisible(pNPC) && pNPC->FVisible( pPlayer ) &&  
#else
if ( FVisible(pNPC) && pNPC->FVisible( UTIL_PlayerByIndex(1) ) && 
#endif //OBCO_Enable_Fixed_Multiplayer_AI		
[/quote]

Line 4034:

[quote]
int CNPC_MetroPolice::SelectSchedule( void )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	if ( !GetEnemy() && HasCondition( COND_IN_PVS ) && pPlayer && !pPlayer->IsAlive() ) 
#else
if ( !GetEnemy() && HasCondition( COND_IN_PVS ) && AI_GetSinglePlayer() && !AI_GetSinglePlayer()->IsAlive() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 5011:

[quote]
		ClearCondition( COND_METROPOLICE_PLAYER_TOO_CLOSE );
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 5149:

[quote]
	if ( pEvent->pObjects[otherIndex]->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CHL2_Player *pPlayer = dynamic_cast<CHL2_Player *>(UTIL_GetNearestPlayer(pHitEntity->GetAbsOrigin())); 
#else
CHL2_Player *pPlayer = dynamic_cast<CHL2_Player *>(UTIL_PlayerByIndex( 1 ));
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_playercompanion.cpp

Line 351:

[quote]
	BaseClass::GatherConditions();

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
//TDT - Null Pointers: Null pointer fixed by KuRouZu on the steam coding forums.
	CBasePlayer *pPlayer = ToBasePlayer( GetFollowBehavior().GetFollowTarget() );//UTIL_GetNearestPlayer(GetAbsOrigin());

	if ( pPlayer ) 
	{
#else
	if ( AI_IsSinglePlayer() )
	
	{
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 510:

[quote]
		DoCustomSpeechAI();
	}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
//TDT - Null Pointers: Null pointer fixed by KuRouZu on the steam coding forums.
	if ( pPlayer && hl2_episodic.GetBool() && !GetEnemy() && HasCondition( COND_HEAR_PLAYER ) )
	{
		Vector los = ( pPlayer->EyePosition() - EyePosition() );
#else
if ( AI_IsSinglePlayer() && hl2_episodic.GetBool() && !GetEnemy() && HasCondition( COND_HEAR_PLAYER ) )
	{
		Vector los = ( UTIL_GetLocalPlayer()->EyePosition() - EyePosition() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 536:

[quote]
void CNPC_PlayerCompanion::DoCustomSpeechAI( void )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 573:

[quote]
void CNPC_PlayerCompanion::PredictPlayerPush()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 988:

[quote]
return true;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
int CNPC_PlayerCompanion::TranslateSchedule( int scheduleType ) 
{
	switch( scheduleType )
	{
	case SCHED_IDLE_STAND:
	case SCHED_ALERT_STAND:
		if( GetActiveWeapon() )
		{
			// Everyone with less than half a clip takes turns reloading when not fighting.
			CBaseCombatWeapon *pWeapon = GetActiveWeapon();

			if( CanReload() && pWeapon->UsesClipsForAmmo1() && pWeapon->Clip1() < ( pWeapon->GetMaxClip1() * .5 ) && OccupyStrategySlot( SQUAD_SLOT_EXCLUSIVE_RELOAD ) )
			{
					CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());

					pWeapon = pPlayer->GetActiveWeapon();
					if( pWeapon && pWeapon->UsesClipsForAmmo1() && 
						pWeapon->Clip1() < ( pWeapon->GetMaxClip1() * .75 ) &&
						pPlayer->GetAmmoCount( pWeapon->GetPrimaryAmmoType() ) )
					{
						SpeakIfAllowed( TLK_PLRELOAD );
					}
				return SCHED_RELOAD;
			}
		}
		break;

	case SCHED_COWER:
		return SCHED_PC_COWER;

	case SCHED_TAKE_COVER_FROM_BEST_SOUND:
		{
			CSound *pSound = GetBestSound(SOUND_DANGER);

			if( pSound && pSound->m_hOwner )
			{
				if( pSound->m_hOwner->IsNPC() && FClassnameIs( pSound->m_hOwner, "npc_zombine" ) )
				{
					// Run fully away from a Zombine with a grenade.
					return SCHED_PC_TAKE_COVER_FROM_BEST_SOUND;
				}
			}

			return SCHED_PC_MOVE_TOWARDS_COVER_FROM_BEST_SOUND;
		}

	case SCHED_FLEE_FROM_BEST_SOUND:
		return SCHED_PC_FLEE_FROM_BEST_SOUND;

	case SCHED_ESTABLISH_LINE_OF_FIRE:
	case SCHED_MOVE_TO_WEAPON_RANGE:
		if ( IsMortar( GetEnemy() ) )
			return SCHED_TAKE_COVER_FROM_ENEMY;
		break;

	case SCHED_CHASE_ENEMY:
		if ( IsMortar( GetEnemy() ) )
			return SCHED_TAKE_COVER_FROM_ENEMY;
		if ( GetEnemy() && FClassnameIs( GetEnemy(), "npc_combinegunship" ) )
			return SCHED_ESTABLISH_LINE_OF_FIRE;
		break;

	case SCHED_ESTABLISH_LINE_OF_FIRE_FALLBACK:
		// If we're fighting a gunship, try again
		if ( GetEnemy() && FClassnameIs( GetEnemy(), "npc_combinegunship" ) )
			return SCHED_ESTABLISH_LINE_OF_FIRE;
		break;

	case SCHED_RANGE_ATTACK1:
		if ( IsMortar( GetEnemy() ) )
			return SCHED_TAKE_COVER_FROM_ENEMY;
			
		if ( GetShotRegulator()->IsInRestInterval() )
			return SCHED_STANDOFF;

		if( !OccupyStrategySlotRange( SQUAD_SLOT_ATTACK1, SQUAD_SLOT_ATTACK2 ) )
			return SCHED_STANDOFF;
		break;

	case SCHED_FAIL_TAKE_COVER:
		if ( IsEnemyTurret() )
		{
			return SCHED_PC_FAIL_TAKE_COVER_TURRET;
		}
		break;
	case SCHED_RUN_FROM_ENEMY_FALLBACK:
		{
			if ( HasCondition( COND_CAN_RANGE_ATTACK1 ) )
			{
				return SCHED_RANGE_ATTACK1;
			}
			break;
		}
	}

	return BaseClass::TranslateSchedule( scheduleType );
}
#else
int CNPC_PlayerCompanion::TranslateSchedule( int scheduleType ) 
{
	switch( scheduleType )
	{
	case SCHED_IDLE_STAND:
	case SCHED_ALERT_STAND:
		if( GetActiveWeapon() )
		{
			// Everyone with less than half a clip takes turns reloading when not fighting.
			CBaseCombatWeapon *pWeapon = GetActiveWeapon();

			if( CanReload() && pWeapon->UsesClipsForAmmo1() && pWeapon->Clip1() < ( pWeapon->GetMaxClip1() * .5 ) && OccupyStrategySlot( SQUAD_SLOT_EXCLUSIVE_RELOAD ) )
			{
				if ( AI_IsSinglePlayer() )
				{
					CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
					pWeapon = pPlayer->GetActiveWeapon();
					if( pWeapon && pWeapon->UsesClipsForAmmo1() && 
						pWeapon->Clip1() < ( pWeapon->GetMaxClip1() * .75 ) &&
						pPlayer->GetAmmoCount( pWeapon->GetPrimaryAmmoType() ) )
					{
						SpeakIfAllowed( TLK_PLRELOAD );
					}
				}
				return SCHED_RELOAD;
			}
		}
		break;

	case SCHED_COWER:
		return SCHED_PC_COWER;

	case SCHED_TAKE_COVER_FROM_BEST_SOUND:
		{
			CSound *pSound = GetBestSound(SOUND_DANGER);

			if( pSound && pSound->m_hOwner )
			{
				if( pSound->m_hOwner->IsNPC() && FClassnameIs( pSound->m_hOwner, "npc_zombine" ) )
				{
					// Run fully away from a Zombine with a grenade.
					return SCHED_PC_TAKE_COVER_FROM_BEST_SOUND;
				}
			}

			return SCHED_PC_MOVE_TOWARDS_COVER_FROM_BEST_SOUND;
		}

	case SCHED_FLEE_FROM_BEST_SOUND:
		return SCHED_PC_FLEE_FROM_BEST_SOUND;

	case SCHED_ESTABLISH_LINE_OF_FIRE:
	case SCHED_MOVE_TO_WEAPON_RANGE:
		if ( IsMortar( GetEnemy() ) )
			return SCHED_TAKE_COVER_FROM_ENEMY;
		break;

	case SCHED_CHASE_ENEMY:
		if ( IsMortar( GetEnemy() ) )
			return SCHED_TAKE_COVER_FROM_ENEMY;
		if ( GetEnemy() && FClassnameIs( GetEnemy(), "npc_combinegunship" ) )
			return SCHED_ESTABLISH_LINE_OF_FIRE;
		break;

	case SCHED_ESTABLISH_LINE_OF_FIRE_FALLBACK:
		// If we're fighting a gunship, try again
		if ( GetEnemy() && FClassnameIs( GetEnemy(), "npc_combinegunship" ) )
			return SCHED_ESTABLISH_LINE_OF_FIRE;
		break;

	case SCHED_RANGE_ATTACK1:
		if ( IsMortar( GetEnemy() ) )
			return SCHED_TAKE_COVER_FROM_ENEMY;
			
		if ( GetShotRegulator()->IsInRestInterval() )
			return SCHED_STANDOFF;

		if( !OccupyStrategySlotRange( SQUAD_SLOT_ATTACK1, SQUAD_SLOT_ATTACK2 ) )
			return SCHED_STANDOFF;
		break;

	case SCHED_FAIL_TAKE_COVER:
		if ( IsEnemyTurret() )
		{
			return SCHED_PC_FAIL_TAKE_COVER_TURRET;
		}
		break;
	case SCHED_RUN_FROM_ENEMY_FALLBACK:
		{
			if ( HasCondition( COND_CAN_RANGE_ATTACK1 ) )
			{
				return SCHED_RANGE_ATTACK1;
			}
			break;
		}
	}

	return BaseClass::TranslateSchedule( scheduleType );
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 1284:

[quote]
		case TASK_PC_GET_PATH_OFF_COMPANION:
			{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					GetNavigator()->SetAllowBigStep( UTIL_GetNearestPlayer(GetAbsOrigin()) );
#else
if ( AI_IsSinglePlayer() )
				{
					GetNavigator()->SetAllowBigStep( UTIL_GetLocalPlayer() );
				}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1649:

[quote]
		if ( m_afMemory & bits_MEMORY_PROVOKED )
			return;
			
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		TestPlayerPushing( ( pOther->IsPlayer() ) ? pOther : UTIL_GetNearestPlayer(GetAbsOrigin()) ); 
#else
TestPlayerPushing( ( pOther->IsPlayer() ) ? pOther : AI_GetSinglePlayer() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1882:

[quote]
			SubtractReadiness( ( 0.1 * (1.0f/GetReadinessDecay())) * m_flReadinessSensitivity );
		}
	}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
 	if( ai_debug_readiness.GetBool() ) 
#else
if( ai_debug_readiness.GetBool() && AI_IsSinglePlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1895:

[quote]
		Vector right;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		UTIL_GetNearestPlayer(GetAbsOrigin())->GetVectors( NULL, &right, NULL ); 
#else
UTIL_PlayerByIndex( 1 )->GetVectors( NULL, &right, NULL );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2039:

[quote]
	flMaxLookTime = flMinLookTime + random->RandomFloat( 0.0f, 0.5f );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	pArgs->flDuration = random->RandomFloat( flMinLookTime, flMaxLookTime ); 
#else
pArgs->flDuration = random->RandomFloat( flMinLookTime, flMaxLookTime );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2050:

[quote]
		if( random->RandomInt( 0, 2 ) == 0 )
		{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			pArgs->hTarget = UTIL_GetNearestVisiblePlayer(this);
#else
pArgs->hTarget = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2942:

[quote]
					UpdateEnemyMemory( pAttacker, pSquadmate->GetAbsOrigin(), pSquadmate );
			}
		}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3182:

[quote]
	float multiplier = 1.0;


#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if ( m_bMovingAwayFromPlayer && (UTIL_GetNearestPlayer(GetAbsOrigin())->GetAbsOrigin() - GetAbsOrigin()).Length2DSqr() < Square(3.0*12.0) ) 
		multiplier = 2.0;

	return BaseClass::GetIdealAccel() * multiplier;
#else
	if ( AI_IsSinglePlayer() )
	{
		if ( m_bMovingAwayFromPlayer && (UTIL_PlayerByIndex(1)->GetAbsOrigin() - GetAbsOrigin()).Length2DSqr() < Square(3.0*12.0) )
			multiplier = 2.0;
	}
	return BaseClass::GetIdealAccel() * multiplier;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
}
[/quote]

Line 3256:

[quote]
void CNPC_PlayerCompanion::InputOutsideTransition( inputdata_t &inputdata )
{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	if ( !AI_IsSinglePlayer() ) 
		return; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3269:

[quote]
	if ( IsInAVehicle() )
		return;

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBaseEntity *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3863:

[quote]
// irrelevant and the player's viewcone is more authorative. -- jdw

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		for (int i = 1; i <= gpGlobals->maxClients; i++ ) 
		{ 
			CBasePlayer *pPlayer = UTIL_PlayerByIndex( i ); 
			if ( !pPlayer ) 
				continue; 

			if ( pPlayer->FInViewCone( EyePosition() ) ) 
				return false;
	} 
#else
CBasePlayer *pLocalPlayer = AI_GetSinglePlayer();
		if ( pLocalPlayer->FInViewCone( EyePosition() ) )
			return false;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_rollermine.cpp

Line 1869:

[quote]
			// If we don't hate the player, we're immune
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_scanner.cpp

Line :

[quote]
	if ( m_bOnlyInspectPlayers )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_strider.cpp

Line 655:

[quote]
		RemoveFlag( FL_FLY );
	}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	m_PlayerFreePass.SetPassTarget( UTIL_GetNearestPlayer(GetAbsOrigin()) ); 
#else
m_PlayerFreePass.SetPassTarget( UTIL_PlayerByIndex(1) );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 786:

[quote]
			text_offset++;
		}
		
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBaseEntity *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
		CBaseEntity *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3143:

[quote]
				CAI_BaseNPC *pAttacker = dynamic_cast<CAI_BaseNPC *>( info.GetAttacker() );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI				
CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3369:

[quote]
		CRagdollProp *pRagdoll = NULL;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI		
[/quote]

.\game\server\hl2\npc_turret_floor.cpp

Line 2039:

[quote]
	Vector vecUserForward;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\hl2\npc_vortigaunt_episodic.cpp

Line 443:

[quote]
		// Wait for the player to get near (before starting the bugbait sequence)
		#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
		#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 647:

[quote]
			return COND_TOO_CLOSE_TO_ATTACK;
		#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetEnemy()->GetAbsOrigin()); 
		#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 909:

[quote]
				// HACK: If we've still failed, just spawn it on the player 
				if ( i == iNumAttempts )
				{
				#ifdef OBCO_Enable_Fixed_Multiplayer_AI
					CBasePlayer	*pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
				#else
				CBasePlayer	*pPlayer = AI_GetSinglePlayer();
				#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1703:

[quote]
	// For now, we only heal the player
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
	#else
	CBasePlayer *pPlayer = AI_GetSinglePlayer();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2365:

[quote]
	//For now the player is always our target
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pTargetEnt = UTIL_GetNearestVisiblePlayer(this); 
	#else
	CBaseEntity *pTargetEnt = AI_GetSinglePlayer();
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\ilagcompensationmanager.h

Line 26:

[quote]
	virtual void	FinishLagCompensation( CBasePlayer *player ) = 0;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	virtual void	RemoveNpcData(int index) = 0; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\logicentities.cpp

Line 2308:

[quote]
void CLogicAutosave::InputSaveDangerous( inputdata_t &inputdata )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer(); 
#else
	CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2361:

[quote]
	void SaveThink()
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
		if ( pPlayer && gpGlobals->maxClients == 1 ) 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
if ( pPlayer )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\maprules.cpp

Line :351

[quote]
	if ( !CanFireForActivator( pActivator ) )
		return;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	// also send to all if we haven't got a specific activator player to send to 
	if ( MessageToAll() || !pActivator || !pActivator->IsPlayer() ) 
#else
if ( MessageToAll() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line :363

[quote]
	else
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		UTIL_HudMessage( ToBasePlayer( pActivator ), m_textParms, MessageGet() );
#else
// If we're in singleplayer, show the message to the player.
		if ( gpGlobals->maxClients == 1 )
		{
			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
			UTIL_HudMessage( pPlayer, m_textParms, MessageGet() );
		}
		// Otherwise show the message to the player that triggered us.
		else if ( pActivator && pActivator->IsNetClient() )
		{
			UTIL_HudMessage( ToBasePlayer( pActivator ), m_textParms, MessageGet() );
		}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\message_entity.cpp

Line 122:

[quote]
	SetNextThink( gpGlobals->curtime + 0.1f );

	// check for player distance
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\monstermaker.cpp

Line 662:

[quote]
			Vector vecTest = pDestination->GetAbsOrigin();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			pPlayer = UTIL_GetNearestPlayer(vecTest); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 732:

[quote]
				Vector vecTest = pDestinations[ i ]->GetAbsOrigin();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				pPlayer = UTIL_GetNearestPlayer(vecTest); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\npc_talker.cpp

Line 231:

[quote]
	case TASK_TALKER_LOOK_AT_CLIENT:

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if ( pTask->iTask == TASK_TALKER_CLIENT_STARE ) 
		{
			// Get edict for one player
			//CBasePlayer *pPlayer = UTIL_GetLocalPlayer(); 
			//Assert( pPlayer ); 
			CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 

			// fail out if the player looks away or moves away.
			if ( !pPlayer || ( pPlayer->GetAbsOrigin() - GetAbsOrigin() ).Length2D() > TALKER_STARE_DIST ) 
#else
if ( pTask->iTask == TASK_TALKER_CLIENT_STARE && AI_IsSinglePlayer() )
		{
			// Get edict for one player
			CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
			Assert( pPlayer );

			// fail out if the player looks away or moves away.
			if ( ( pPlayer->GetAbsOrigin() - GetAbsOrigin() ).Length2D() > TALKER_STARE_DIST )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 838:

[quote]
	// failed to speak, so look at the player if he's around
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( GetExpresser()->CanSpeak() && HasCondition ( COND_SEE_PLAYER ) && random->RandomInt( 0, 6 ) == 0 ) 
	{ 
CBasePlayer *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
	if ( AI_IsSinglePlayer() && GetExpresser()->CanSpeak() && HasCondition ( COND_SEE_PLAYER ) && random->RandomInt( 0, 6 ) == 0 )
	{
		CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
		Assert( pPlayer );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\phsyics_npc_solver.cpp

Line 300:

[quote]
		if ( pObject->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
		{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			Vector origin; 
			pObject->GetPosition(&origin,NULL); 
			CBasePlayer *pPlayer = UTIL_GetNearestPlayer(origin); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\player.cpp

Line 167:

[quote]
void CC_GiveCurrentAmmo( void )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetCommandClient(); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 705:

[quote]
	return BaseClass::ShouldTransmit( pInfo );
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
bool CBasePlayer::WantsLagCompensationOnEntity( const CBaseEntity *pEntity, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const 
{
	//Tony; only check teams in teamplay
	if ( gpGlobals->teamplay )
	{
		// Team members shouldn't be adjusted unless friendly fire is on.
		if ( !friendlyfire.GetInt() && pEntity->GetTeamNumber() == GetTeamNumber() ) 
			return false;
	}

	// If this entity hasn't been transmitted to us and acked, then don't bother lag compensating it.
	if ( pEntityTransmitBits && !pEntityTransmitBits->Get( pEntity->entindex() ) ) 
		return false;

	const Vector &vMyOrigin = GetAbsOrigin();
	const Vector &vHisOrigin = pEntity->GetAbsOrigin();

	// get max distance player could have moved within max lag compensation time, 
	// multiply by 1.5 to to avoid "dead zones"  (sqrt(2) would be the exact value)
	//float maxDistance = 1.5 * pPlayer->MaxSpeed() * sv_maxunlag.GetFloat(); 
	float maxspeed; 
	CBasePlayer *pPlayer = ToBasePlayer((CBaseEntity*)pEntity); 
	if ( pPlayer ) 
		maxspeed = pPlayer->MaxSpeed(); 
	else 
		maxspeed = 600; 
	float maxDistance = 1.5 * maxspeed * sv_maxunlag.GetFloat(); 
#else
bool CBasePlayer::WantsLagCompensationOnEntity( const CBasePlayer *pPlayer, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const
{
	//Tony; only check teams in teamplay
	if ( gpGlobals->teamplay )
	{
		// Team members shouldn't be adjusted unless friendly fire is on.
		if ( !friendlyfire.GetInt() && pPlayer->GetTeamNumber() == GetTeamNumber() )
			return false;
	}

	// If this entity hasn't been transmitted to us and acked, then don't bother lag compensating it.
	if ( pEntityTransmitBits && !pEntityTransmitBits->Get( pPlayer->entindex() ) )
		return false;

	const Vector &vMyOrigin = GetAbsOrigin();
	const Vector &vHisOrigin = pPlayer->GetAbsOrigin();

	// get max distance player could have moved within max lag compensation time, 
	// multiply by 1.5 to to avoid "dead zones"  (sqrt(2) would be the exact value)
	float maxDistance = 1.5 * pPlayer->MaxSpeed() * sv_maxunlag.GetFloat();
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 7638:

[quote]
	else if ( !g_pGameRules->IsDeathmatch() )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	for (int i = 1; i <= gpGlobals->maxClients; i++ ) 
	{ 
		CBasePlayer *pPlayer = UTIL_PlayerByIndex( i ); 
		if ( pPlayer )
		{
		pPlayer->RemoveAllItems( stripSuit );
		}
	}
#else
pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 7744:

[quote]
SetThink( &CRevertSaved::LoadThink );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	for (int i = 1; i <= gpGlobals->maxClients; i++ ) 
	{ 
		CBasePlayer *pPlayer = UTIL_PlayerByIndex( i ); 
		if ( !pPlayer ) 
			continue; 
			
			if ( pPlayer )
			{		
			//Adrian: Setting this flag so we can't move or save a game.
			pPlayer->pl.deadflag = true;
			pPlayer->AddFlag( (FL_NOTARGET|FL_FROZEN) );

			// clear any pending autosavedangerous
			g_ServerGameDLL.m_fAutoSaveDangerousTime = 0.0f;
			g_ServerGameDLL.m_fAutoSaveDangerousMinHealthToCommit = 0.0f;
			}
	}
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();

	if ( pPlayer )
	{
		//Adrian: Setting this flag so we can't move or save a game.
		pPlayer->pl.deadflag = true;
		pPlayer->AddFlag( (FL_NOTARGET|FL_FROZEN) );

		// clear any pending autosavedangerous
		g_ServerGameDLL.m_fAutoSaveDangerousTime = 0.0f;
		g_ServerGameDLL.m_fAutoSaveDangerousMinHealthToCommit = 0.0f;
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 7826:

[quote]
		engine->ServerCommand("reload\n");
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
//TDT - Information: Here we change level to the map we're already on if a vital ally such as Alyx is killed etc etc etc.
	else
	{
	char *szDefaultMapName = new char[32];
	Q_strncpy( szDefaultMapName, STRING(gpGlobals->mapname), 32 );
	engine->ChangeLevel( szDefaultMapName, NULL );
	return;
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 7912:

[quote]
	else if ( !g_pGameRules->IsDeathmatch() )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\player.h

Line 304:

[quote]
	// (like team members, entities out of our PVS, etc).
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	virtual bool			WantsLagCompensationOnEntity( const CBaseEntity	*pEntity, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const;
#else
	virtual bool			WantsLagCompensationOnEntity( const CBasePlayer	*pPlayer, const CUserCmd *pCmd, const CBitVec<MAX_EDICTS> *pEntityTransmitBits ) const;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\player_lagcompensation.cpp

Line 16:

[quote]
#include "BaseAnimatingOverlay.h"

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#include "ai_basenpc.h" 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 170:

[quote]
// Cool, the player can go back to whence he came.
		UTIL_SetOrigin( pPlayer, tr.endpos, true );
	}
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI

static void RestoreEntityTo( CAI_BaseNPC *pEntity, const Vector &vWantedPos )
{
	// Try to move to the wanted position from our current position.
	trace_t tr;
	VPROF_BUDGET( "RestoreEntityTo", "CLagCompensationManager" );
	UTIL_TraceEntity( pEntity, vWantedPos, vWantedPos, MASK_NPCSOLID, pEntity, COLLISION_GROUP_NPC, &tr );
	if ( tr.startsolid || tr.allsolid )
	{
		if ( sv_unlag_debug.GetBool() )
		{
			DevMsg( "RestorepEntityTo() could not restore entity position for %s ( %.1f %.1f %.1f )\n",
					pEntity->GetClassname(), vWantedPos.x, vWantedPos.y, vWantedPos.z );
		}

		UTIL_TraceEntity( pEntity, pEntity->GetLocalOrigin(), vWantedPos, MASK_NPCSOLID, pEntity, COLLISION_GROUP_NPC, &tr );
		if ( tr.startsolid || tr.allsolid )
		{
			// In this case, the guy got stuck back wherever we lag compensated him to. Nasty.

			if ( sv_unlag_debug.GetBool() )
				DevMsg( " restore failed entirely\n" );
		}
		else
		{
			// We can get to a valid place, but not all the way back to where we were.
			Vector vPos;
			VectorLerp( pEntity->GetLocalOrigin(), vWantedPos, tr.fraction * g_flFractionScale, vPos );
			UTIL_SetOrigin( pEntity, vPos, true );

			if ( sv_unlag_debug.GetBool() )
				DevMsg( " restore got most of the way\n" );
		}
	}
	else
	{
		// Cool, the entity can go back to whence he came.
		UTIL_SetOrigin( pEntity, tr.endpos, true );
	}
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 221:

[quote]
	CLagCompensationManager( char const *name ) : CAutoGameSystemPerFrame( name )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	m_bNeedsAIUpdate = true; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 245:

[quote]
	void			FinishLagCompensation( CBasePlayer *player );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	void RemoveNpcData(int index) // clear specific NPC's history 
	{ 
		CUtlFixedLinkedList< LagRecord > *track = &m_EntityTrack[index]; 
		track->Purge(); 
	} 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 262:

[quote]
			m_PlayerTrack[i].Purge();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			for ( int j=0; j<MAX_AIS; j++ ) 
			m_EntityTrack[j].Purge(); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 267:

[quote]
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
void UpdateAIIndexes(); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 273:

[quote]
	CUtlFixedLinkedList< LagRecord >	m_PlayerTrack[ MAX_PLAYERS ];

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CUtlFixedLinkedList< LagRecord >	m_EntityTrack[ MAX_AIS ]; 
#endif OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 280:

[quote]
	CBitVec<MAX_PLAYERS>	m_RestorePlayer;

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBitVec<MAX_AIS>		m_RestoreEntity; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 289:

[quote]
	LagRecord				m_ChangeData[ MAX_PLAYERS ];	// player data where we moved him back

#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	LagRecord				m_EntityRestoreData[ MAX_AIS ]; 
	LagRecord				m_EntityChangeData[ MAX_AIS ]; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI

[/quote]

Line 296:

[quote]
	CBasePlayer				*m_pCurrentPlayer;	// The player we are doing lag compensation for

#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	bool					m_bNeedsAIUpdate; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 310:

[quote]
void CLagCompensationManager::FrameUpdatePostEntityThink()
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
if ( m_bNeedsAIUpdate ) 
		UpdateAIIndexes(); // only bother if we haven't had one yet 
	else // setting this true here ensures that the update happens at the start of the next frame 
		m_bNeedsAIUpdate = true; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 402:

[quote]
	record.m_masterCycle = pPlayer->GetCycle();
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	// Iterate all active NPCs
	CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs();
	int nAIs = g_AI_Manager.NumAIs();

	for ( int i = 0; i < nAIs; i++ )
	{
		CAI_BaseNPC *pNPC = ppAIs[i];
		CUtlFixedLinkedList< LagRecord > *track = &m_EntityTrack[i];

		if ( !pNPC )
		{
			track->RemoveAll();
			continue;
		}

		Assert( track->Count() < 1000 ); // insanity check

		// remove tail records that are too old
		int tailIndex = track->Tail();
		while ( track->IsValidIndex( tailIndex ) )
		{
			LagRecord &tail = track->Element( tailIndex );

			// if tail is within limits, stop
			if ( tail.m_flSimulationTime >= flDeadtime )
				break;
			
			// remove tail, get new tail
			track->Remove( tailIndex );
			tailIndex = track->Tail();
		}

		// check if head has same simulation time
		if ( track->Count() > 0 )
		{
			LagRecord &head = track->Element( track->Head() );

			// check if entity changed simulation time since last time updated
			if ( &head && head.m_flSimulationTime >= pNPC->GetSimulationTime() )
				continue; // don't add new entry for same or older time

			// Simulation Time is set when an entity moves or rotates ...
			// this error occurs when whatever entity it is that breaks it moves or rotates then, presumably?
		}

		// add new record to track
		LagRecord &record = track->Element( track->AddToHead() );

	record.m_fFlags = 0;
		if ( pNPC->IsAlive() )
		{
			record.m_fFlags |= LC_ALIVE;
		}

		record.m_flSimulationTime	= pNPC->GetSimulationTime();
		record.m_vecAngles			= pNPC->GetLocalAngles();
		record.m_vecOrigin			= pNPC->GetLocalOrigin();
		record.m_vecMaxs			= pNPC->WorldAlignMaxs();
		record.m_vecMins			= pNPC->WorldAlignMins();

		int layerCount = pNPC->GetNumAnimOverlays();
		for( int layerIndex = 0; layerIndex < layerCount; ++layerIndex )
		{
			CAnimationLayer *currentLayer = pNPC->GetAnimOverlay(layerIndex);
			if( currentLayer )
			{
				record.m_layerRecords[layerIndex].m_cycle = currentLayer->m_flCycle;
				record.m_layerRecords[layerIndex].m_order = currentLayer->m_nOrder;
				record.m_layerRecords[layerIndex].m_sequence = currentLayer->m_nSequence;
				record.m_layerRecords[layerIndex].m_weight = currentLayer->m_flWeight;
			}
		}
		record.m_masterSequence = pNPC->GetSequence();
		record.m_masterCycle = pNPC->GetCycle();
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 481:

[quote]
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
void CLagCompensationManager::UpdateAIIndexes()
{
	CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs();
	int nAIs = g_AI_Manager.NumAIs();

	for ( int i = 0; i < nAIs; i++ )
	{
		CAI_BaseNPC *pNPC = ppAIs[i];
		if ( pNPC && pNPC->GetAIIndex() != i ) // index of NPC has changed
		{// move their data to their new index, probably wanting to delete the old track record
			int oldIndex = pNPC->GetAIIndex();
			int newIndex = i;

			//Msg("Lag compensation record adjusting, moving from index %i to %i\n",oldIndex,newIndex);

			CUtlFixedLinkedList< LagRecord > *track = &m_EntityTrack[ oldIndex ];
			CUtlFixedLinkedList< LagRecord > *oldTrack = &m_EntityTrack[ newIndex ];

			m_EntityTrack[oldIndex] = *oldTrack;
			m_EntityTrack[newIndex] = *track;
			if ( oldTrack->Count() > 0 ) // there's data in the auld yin, probably from someone newly dead,
			{// but if not we'll swap them round so that the old one can then fix their AI index
				//Msg("Index %i already contains data!\n",newIndex);
				for ( int j=0; j<nAIs; j++ )
				{
					CAI_BaseNPC *pConflictingNPC = ppAIs[j];
					if ( pConflictingNPC && pConflictingNPC->GetAIIndex() == newIndex )
					{// found the conflicting NPC, swap them into the old index
						pConflictingNPC->SetAIIndex(oldIndex); // presumably they'll fix themselves further down the loop
						Warning("Lag compensation adjusting entity index, swapping with an existing entity! (%i & %i)\n",oldIndex,newIndex);
						break;
					}
				}
			}

			pNPC->SetAIIndex(newIndex);
		}
	}
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 526:

[quote]
void CLagCompensationManager::StartLagCompensation( CBasePlayer *player, CUserCmd *cmd )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		// sort out any changes to the AI indexing 
	if ( m_bNeedsAIUpdate ) // to be called once per frame... must happen BEFORE lag compensation - 
	{// if that happens, that is. if not its called at the end of the frame 
		m_bNeedsAIUpdate = false; 
		UpdateAIIndexes(); 
	} 

	// Assume no players or entities need to be restored 

	m_RestorePlayer.ClearAll();
	m_RestoreEntity.ClearAll(); 
#else
// Assume no players need to be restored
	m_RestorePlayer.ClearAll();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 559:

[quote]
	Q_memset( m_ChangeData, 0, sizeof( m_ChangeData ) );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	Q_memset( m_EntityRestoreData, 0, sizeof( m_EntityRestoreData ) ); 
	Q_memset( m_EntityChangeData, 0, sizeof( m_EntityChangeData ) ); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 604:

[quote]
CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if ( !pPlayer || player == pPlayer ) 
			continue;
#else
if ( !pPlayer )
		{
			continue;
		}

		// Don't lag compensate yourself you loser...
		if ( player == pPlayer )
		{
			continue;
		}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 627:

[quote]
BacktrackPlayer( pPlayer, TICKS_TO_TIME( targettick ) );
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	
	// also iterate all monsters 
	CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs(); 
	int nAIs = g_AI_Manager.NumAIs(); 

	for ( int i = 0; i < nAIs; i++ ) 
	{ 
		CAI_BaseNPC *pNPC = ppAIs[i]; 
		// Custom checks for if things should lag compensate 
		if ( !pNPC || !player->WantsLagCompensationOnEntity( pNPC, cmd, pEntityTransmitBits ) ) 
			continue; 
		
		// Move NPC back in time 
		BacktrackEntity( pNPC, TICKS_TO_TIME( targettick ) ); 
	} 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 777:

[quote]
	// Remove the temp flag
					m_RestorePlayer.Clear( pl_index );
				}				
			}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
						else
			{
				CAI_BaseNPC *pHitEntity = dynamic_cast<CAI_BaseNPC *>( tr.m_pEnt );
				if ( pHitEntity )
				{
					CAI_BaseNPC *pNPC = NULL;
					CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs();
					int nAIs = g_AI_Manager.NumAIs();
					for ( int i = 0; i < nAIs; i++ ) // we'll have to find this entity's index though :(
					{
						pNPC = ppAIs[i];
						if ( pNPC == pHitEntity )
							break;
					}
					// If we haven't backtracked this player, do it now
					// this deliberately ignores WantsLagCompensationOnEntity.
					if ( pNPC && !m_RestoreEntity.Get( pNPC->GetAIIndex() ) )
					{
						// prevent recursion - save a copy of m_RestoreEntity,
						// pretend that this player is off-limits
 
						// Temp turn this flag on
						m_RestoreEntity.Set( pNPC->GetAIIndex() );

						BacktrackEntity( pHitEntity, flTargetTime );

						// Remove the temp flag
						m_RestoreEntity.Clear( pNPC->GetAIIndex() );
					}
				}
			}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote

Line 990:

[quote]
	pPlayer->DrawServerHitboxes(4, true);
	}
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
void CLagCompensationManager::BacktrackEntity( CAI_BaseNPC *pEntity, float flTargetTime )
{
	Vector org, mins, maxs;
	QAngle ang;

	VPROF_BUDGET( "BacktrackEntity", "CLagCompensationManager" );

	// get track history of this entity
	int index = pEntity->GetAIIndex();
	CUtlFixedLinkedList< LagRecord > *track = &m_EntityTrack[ index ];

	// check if we have at leat one entry
	if ( track->Count() <= 0 )
		return;

	int curr = track->Head();

	LagRecord *prevRecord = NULL;
	LagRecord *record = NULL;

	Vector prevOrg = pEntity->GetLocalOrigin();
	
	// Walk context looking for any invalidating event
	while( track->IsValidIndex(curr) )
	{
		// remember last record
		prevRecord = record;

		// get next record
		record = &track->Element( curr );

		if ( !(record->m_fFlags & LC_ALIVE) )
		{
			// entity must be alive, lost track
			return;
		}

		Vector delta = record->m_vecOrigin - prevOrg;
		if ( delta.LengthSqr() > LAG_COMPENSATION_TELEPORTED_DISTANCE_SQR )
		{
			// lost track, moved too far (may have teleported)
			return; 
		}

		// did we find a context smaller than target time ?
		if ( record->m_flSimulationTime <= flTargetTime )
			break; // hurra, stop

		prevOrg = record->m_vecOrigin;

		// go one step back in time
		curr = track->Next( curr );
	}

	Assert( record );

	if ( !record )
	{
		if ( sv_unlag_debug.GetBool() )
		{
			DevMsg( "No valid positions in history for BacktrackEntity ( %s )\n", pEntity->GetClassname() );
		}

		return; // that should never happen
	}

	float frac = 0.0f;
	if ( prevRecord && 
		 (record->m_flSimulationTime < flTargetTime) &&
		 (record->m_flSimulationTime < prevRecord->m_flSimulationTime) )
	{
		// we didn't find the exact time but have a valid previous record
		// so interpolate between these two records;

		Assert( prevRecord->m_flSimulationTime > record->m_flSimulationTime );
		Assert( flTargetTime < prevRecord->m_flSimulationTime );

		// calc fraction between both records
		frac = ( flTargetTime - record->m_flSimulationTime ) / 
			( prevRecord->m_flSimulationTime - record->m_flSimulationTime );

		Assert( frac > 0 && frac < 1 ); // should never extrapolate

		ang  = Lerp( frac, record->m_vecAngles, prevRecord->m_vecAngles );
		org  = Lerp( frac, record->m_vecOrigin, prevRecord->m_vecOrigin  );
		mins = Lerp( frac, record->m_vecMins, prevRecord->m_vecMins  );
		maxs = Lerp( frac, record->m_vecMaxs, prevRecord->m_vecMaxs );
	}
	else
	{
		// we found the exact record or no other record to interpolate with
		// just copy these values since they are the best we have
		ang  = record->m_vecAngles;
		org  = record->m_vecOrigin;
		mins = record->m_vecMins;
		maxs = record->m_vecMaxs;
	}

	// See if this is still a valid position for us to teleport to
	if ( sv_unlag_fixstuck.GetBool() )
	{
		// Try to move to the wanted position from our current position.
		trace_t tr;
		UTIL_TraceEntity( pEntity, org, org, MASK_NPCSOLID, &tr );
		if ( tr.startsolid || tr.allsolid )
		{
			if ( sv_unlag_debug.GetBool() )
				DevMsg( "WARNING: BackupEntity trying to back entity into a bad position - %s\n", pEntity->GetClassname() );

			CBasePlayer *pHitPlayer = dynamic_cast<CBasePlayer *>( tr.m_pEnt );

			// don't lag compensate the current player
			if ( pHitPlayer && ( pHitPlayer != m_pCurrentPlayer ) )	
			{
				// If we haven't backtracked this player, do it now
				// this deliberately ignores WantsLagCompensationOnEntity.
				if ( !m_RestorePlayer.Get( pHitPlayer->entindex() - 1 ) )
				{
					// prevent recursion - save a copy of m_RestorePlayer,
					// pretend that this player is off-limits
					int pl_index = pEntity->entindex() - 1;

					// Temp turn this flag on
					m_RestorePlayer.Set( pl_index );

					BacktrackPlayer( pHitPlayer, flTargetTime );

					// Remove the temp flag
					m_RestorePlayer.Clear( pl_index );
				}				
			}
			else
			{
				CAI_BaseNPC *pHitEntity = dynamic_cast<CAI_BaseNPC *>( tr.m_pEnt );
				if ( pHitEntity )
				{
					CAI_BaseNPC *pNPC = NULL;
					CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs();
					int nAIs = g_AI_Manager.NumAIs();
					for ( int i = 0; i < nAIs; i++ ) // we'll have to find this entity's index though :(
					{
						pNPC = ppAIs[i];
						if ( pNPC == pHitEntity )
							break;
					}
					// If we haven't backtracked this player, do it now
					// this deliberately ignores WantsLagCompensationOnEntity.
					if ( pNPC && !m_RestoreEntity.Get( pNPC->GetAIIndex() ) )
					{
						// prevent recursion - save a copy of m_RestoreEntity,
						// pretend that this player is off-limits

						// Temp turn this flag on
						m_RestoreEntity.Set( pNPC->GetAIIndex() );

						BacktrackEntity( pHitEntity, flTargetTime );

						// Remove the temp flag
						m_RestoreEntity.Clear( pNPC->GetAIIndex() );
					}
				}
			}

			// now trace us back as far as we can go
			UTIL_TraceEntity( pEntity, pEntity->GetLocalOrigin(), org, MASK_NPCSOLID, &tr );

			if ( tr.startsolid || tr.allsolid )
			{
				// Our starting position is bogus

				if ( sv_unlag_debug.GetBool() )
					DevMsg( "Backtrack failed completely, bad starting position\n" );
			}
			else
			{
				// We can get to a valid place, but not all the way to the target
				Vector vPos;
				VectorLerp( pEntity->GetLocalOrigin(), org, tr.fraction * g_flFractionScale, vPos );
				
				// This is as close as we're going to get
				org = vPos;

				if ( sv_unlag_debug.GetBool() )
					DevMsg( "Backtrack got most of the way\n" );
			}
		}
	}
	
	// See if this represents a change for the entity
	int flags = 0;
	LagRecord *restore = &m_EntityRestoreData[ index ];
	LagRecord *change  = &m_EntityChangeData[ index ];

	QAngle angdiff = pEntity->GetLocalAngles() - ang;
	Vector orgdiff = pEntity->GetLocalOrigin() - org;

	// Always remember the pristine simulation time in case we need to restore it.
	restore->m_flSimulationTime = pEntity->GetSimulationTime();

	if ( angdiff.LengthSqr() > LAG_COMPENSATION_EPS_SQR )
	{
		flags |= LC_ANGLES_CHANGED;
		restore->m_vecAngles = pEntity->GetLocalAngles();
		pEntity->SetLocalAngles( ang );
		change->m_vecAngles = ang;
	}

	// Use absolute equality here
	if ( ( mins != pEntity->WorldAlignMins() ) ||
		 ( maxs != pEntity->WorldAlignMaxs() ) )
	{
		flags |= LC_SIZE_CHANGED;
		restore->m_vecMins = pEntity->WorldAlignMins() ;
		restore->m_vecMaxs = pEntity->WorldAlignMaxs();
		pEntity->SetSize( mins, maxs );
		change->m_vecMins = mins;
		change->m_vecMaxs = maxs;
	}

	// Note, do origin at end since it causes a relink into the k/d tree
	if ( orgdiff.LengthSqr() > LAG_COMPENSATION_EPS_SQR )
	{
		flags |= LC_ORIGIN_CHANGED;
		restore->m_vecOrigin = pEntity->GetLocalOrigin();
		pEntity->SetLocalOrigin( org );
		change->m_vecOrigin = org;
	}

	// Sorry for the loss of the optimization for the case of people
	// standing still, but you breathe even on the server.
	// This is quicker than actually comparing all bazillion floats.
	flags |= LC_ANIMATION_CHANGED;
	restore->m_masterSequence = pEntity->GetSequence();
	restore->m_masterCycle = pEntity->GetCycle();

	bool interpolationAllowed = false;
	if( prevRecord && (record->m_masterSequence == prevRecord->m_masterSequence) )
	{
		// If the master state changes, all layers will be invalid too, so don't interp (ya know, interp barely ever happens anyway)
		interpolationAllowed = true;
	}
	
	////////////////////////
	// First do the master settings
	bool interpolatedMasters = false;
	if( frac > 0.0f && interpolationAllowed )
	{
		interpolatedMasters = true;
		pEntity->SetSequence( Lerp( frac, record->m_masterSequence, prevRecord->m_masterSequence ) );
		pEntity->SetCycle( Lerp( frac, record->m_masterCycle, prevRecord->m_masterCycle ) );

		if( record->m_masterCycle > prevRecord->m_masterCycle )
		{
			// the older record is higher in frame than the newer, it must have wrapped around from 1 back to 0
			// add one to the newer so it is lerping from .9 to 1.1 instead of .9 to .1, for example.
			float newCycle = Lerp( frac, record->m_masterCycle, prevRecord->m_masterCycle + 1 );
			pEntity->SetCycle(newCycle < 1 ? newCycle : newCycle - 1 );// and make sure .9 to 1.2 does not end up 1.05
		}
		else
		{
			pEntity->SetCycle( Lerp( frac, record->m_masterCycle, prevRecord->m_masterCycle ) );
		}
	}
	if( !interpolatedMasters )
	{
		pEntity->SetSequence(record->m_masterSequence);
		pEntity->SetCycle(record->m_masterCycle);
	}

	////////////////////////
	// Now do all the layers
	int layerCount = pEntity->GetNumAnimOverlays();
	for( int layerIndex = 0; layerIndex < layerCount; ++layerIndex )
	{
		CAnimationLayer *currentLayer = pEntity->GetAnimOverlay(layerIndex);
		if( currentLayer )
		{
			restore->m_layerRecords[layerIndex].m_cycle = currentLayer->m_flCycle;
			restore->m_layerRecords[layerIndex].m_order = currentLayer->m_nOrder;
			restore->m_layerRecords[layerIndex].m_sequence = currentLayer->m_nSequence;
			restore->m_layerRecords[layerIndex].m_weight = currentLayer->m_flWeight;

			bool interpolated = false;
			if( (frac > 0.0f)  &&  interpolationAllowed )
			{
				LayerRecord &recordsLayerRecord = record->m_layerRecords[layerIndex];
				LayerRecord &prevRecordsLayerRecord = prevRecord->m_layerRecords[layerIndex];
				if( (recordsLayerRecord.m_order == prevRecordsLayerRecord.m_order)
					&& (recordsLayerRecord.m_sequence == prevRecordsLayerRecord.m_sequence)
					)
				{
					// We can't interpolate across a sequence or order change
					interpolated = true;
					if( recordsLayerRecord.m_cycle > prevRecordsLayerRecord.m_cycle )
					{
						// the older record is higher in frame than the newer, it must have wrapped around from 1 back to 0
						// add one to the newer so it is lerping from .9 to 1.1 instead of .9 to .1, for example.
						float newCycle = Lerp( frac, recordsLayerRecord.m_cycle, prevRecordsLayerRecord.m_cycle + 1 );
						currentLayer->m_flCycle = newCycle < 1 ? newCycle : newCycle - 1;// and make sure .9 to 1.2 does not end up 1.05
					}
					else
					{
						currentLayer->m_flCycle = Lerp( frac, recordsLayerRecord.m_cycle, prevRecordsLayerRecord.m_cycle  );
					}
					currentLayer->m_nOrder = recordsLayerRecord.m_order;
					currentLayer->m_nSequence = recordsLayerRecord.m_sequence;
					currentLayer->m_flWeight = Lerp( frac, recordsLayerRecord.m_weight, prevRecordsLayerRecord.m_weight  );
				}
			}
			if( !interpolated )
			{
				//Either no interp, or interp failed.  Just use record.
				currentLayer->m_flCycle = record->m_layerRecords[layerIndex].m_cycle;
				currentLayer->m_nOrder = record->m_layerRecords[layerIndex].m_order;
				currentLayer->m_nSequence = record->m_layerRecords[layerIndex].m_sequence;
				currentLayer->m_flWeight = record->m_layerRecords[layerIndex].m_weight;
			}
		}
	}
	
	if ( !flags )
		return; // we didn't change anything

	if ( sv_lagflushbonecache.GetBool() )
		pEntity->InvalidateBoneCache();

	/*char text[256]; Q_snprintf( text, sizeof(text), "time %.2f", flTargetTime );
	pEntity->DrawServerHitboxes( 10 );
	NDebugOverlay::Text( org, text, false, 10 );
	NDebugOverlay::EntityBounds( pEntity, 255, 0, 0, 32, 10 ); */

	m_RestoreEntity.Set( index ); //remember that we changed this entity
	m_bNeedToRestore = true;  // we changed at least one player / entity
	restore->m_fFlags = flags; // we need to restore these flags
	change->m_fFlags = flags; // we have changed these flags

	if( sv_showlagcompensation.GetInt() == 1 )
	{
		pEntity->DrawServerHitboxes(4, true);
	}
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1425:

[quote]
pPlayer->SetSimulationTime( restore->m_flSimulationTime );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		}
	}
	
	// also iterate all monsters
	CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs();
	int nAIs = g_AI_Manager.NumAIs();

	for ( int i = 0; i < nAIs; i++ )
	{
		CAI_BaseNPC *pNPC = ppAIs[i];
		
		if ( !m_RestoreEntity.Get( i ) )
		{
			// entity wasn't changed by lag compensation
			continue;
		}

		LagRecord *restore = &m_EntityRestoreData[ i ];
		LagRecord *change  = &m_EntityChangeData[ i ];

		bool restoreSimulationTime = false;

		if ( restore->m_fFlags & LC_SIZE_CHANGED )
		{
			restoreSimulationTime = true;
	
			// see if simulation made any changes, if no, then do the restore, otherwise,
			//  leave new values in
			if ( pNPC->WorldAlignMins() == change->m_vecMins && 
				 pNPC->WorldAlignMaxs() == change->m_vecMaxs )
			{
				// Restore it
				pNPC->SetSize( restore->m_vecMins, restore->m_vecMaxs );
			}
		}

		if ( restore->m_fFlags & LC_ANGLES_CHANGED )
		{		   
			restoreSimulationTime = true;

			if ( pNPC->GetLocalAngles() == change->m_vecAngles )
			{
				pNPC->SetLocalAngles( restore->m_vecAngles );
			}
		}

		if ( restore->m_fFlags & LC_ORIGIN_CHANGED )
		{
			restoreSimulationTime = true;

			// Okay, let's see if we can do something reasonable with the change
			Vector delta = pNPC->GetLocalOrigin() - change->m_vecOrigin;
			
			// If it moved really far, just leave the player in the new spot!!!
			if ( delta.LengthSqr() < LAG_COMPENSATION_TELEPORTED_DISTANCE_SQR )
			{
				RestoreEntityTo( pNPC, restore->m_vecOrigin + delta );
			}
		}

		if( restore->m_fFlags & LC_ANIMATION_CHANGED )
		{
			restoreSimulationTime = true;

			pNPC->SetSequence(restore->m_masterSequence);
			pNPC->SetCycle(restore->m_masterCycle);

			int layerCount = pNPC->GetNumAnimOverlays();
			for( int layerIndex = 0; layerIndex < layerCount; ++layerIndex )
			{
				CAnimationLayer *currentLayer = pNPC->GetAnimOverlay(layerIndex);
				if( currentLayer )
				{
					currentLayer->m_flCycle = restore->m_layerRecords[layerIndex].m_cycle;
					currentLayer->m_nOrder = restore->m_layerRecords[layerIndex].m_order;
					currentLayer->m_nSequence = restore->m_layerRecords[layerIndex].m_sequence;
					currentLayer->m_flWeight = restore->m_layerRecords[layerIndex].m_weight;
				}
			}
		}

		if ( restoreSimulationTime )
		{
			pNPC->SetSimulationTime( restore->m_flSimulationTime );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\player_pickup.cpp

Line 27:

[quote]
	if ( pPhysics->GetGameFlags() & FVPHYSICS_PLAYER_HELD )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(pTarget->GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\sceneentity.cpp

Line 3735:

[quote]
	if ( !stricmp( name, "Player" ) || !stricmp( name, "!player" ))
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		entity = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
	}
[/quote]

Line 3866:

[quote]
	else if ( !stricmp( name, "Player" ) || !stricmp( name, "!player" ))
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		entity = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;		
#endif //OBCO_Enable_Fixed_Multiplayer_AI
		return entity;
[/quote]

.\game\server\soundscape.cpp

Line 340:

[quote]
		NDebugOverlay::Box(GetAbsOrigin(), Vector(-10,-10,-10), Vector(10,10,10),  255, 0, 255, 64, NDEBUG_PERSIST_TILL_NEXT_SERVER );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetLocalPlayer(); 
#else
// Don't use GetLocalPlayer(), because that prevents multiplayer games using this for testing with a single client in the game
		CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\test_stressentities.cpp

Line 29:

[quote]
	if ( pEnt )
	{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		UTIL_SetOrigin( pEnt, GetRandomSpot() );
#else
CBasePlayer *pLocalPlayer = UTIL_GetLocalPlayer();
		if ( pLocalPlayer )
		{			
			Vector vForward;
			pLocalPlayer->EyeVectors(&vForward );

			UTIL_SetOrigin( pEnt, GetRandomSpot() );
		}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\triggers.cpp

Line 2581:

[quote]
			// A previous dangerous auto save was waiting to become safe
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2605:

[quote]
		// There's a dangerous timer. Save if we have enough hitpoints.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		CBasePlayer *pPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex( 1 );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3033:

[quote]
	Msg ("Not m_hPlayer or m_hPlayer isn't a player!");
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		m_hPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
		Msg ("m_hPlayer should now be the nearest player.");
#else
m_hPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3234:

[quote]
	if ( !m_hPlayer || !m_hPlayer->IsPlayer() )
	{
#ifdef obco_Enable_Fixed_Multiplayer_AI
		m_hPlayer = UTIL_GetNearestPlayer(GetAbsOrigin()); 
#else
m_hPlayer = UTIL_GetLocalPlayer();
#endif //obco_Enable_Fixed_Multiplayer_AI
[/quote]

Line 3483:

[quote]
			((CBasePlayer*)m_hPlayer.Get())->GetActiveWeapon()->RemoveEffects( EF_NODRAW );
		}
	}

	//TDT - Null Pointers: On ep2_outland_01 the game would crash as it didn't find a player, so define them as the nearest player.
#ifdef obco_Enable_Fixed_Multiplayer_AI	
	CBasePlayer *m_hPlayer = UTIL_GetNearestPlayer(GetAbsOrigin());
#endif //obco_Enable_Fixed_Multiplayer_AI
	//return the player to previous takedamage state
[/quote]

Line 3767:

[quote]
	// manually find the single player. 
	pClient = engine->PEntityOfEntIndex( 1 );

#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	Assert(gpGlobals->maxClients == 1); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\util.cpp

Line 611:

[quote]
//
// Return the local player.
// If this is a multiplayer game, return NULL.
//
 
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *UTIL_GetLocalPlayer( void )
{

	// first try getting the host, failing that, get *ANY* player
	CBasePlayer *pHost = UTIL_GetListenServerHost();
	if ( pHost )
		return pHost;

	for (int i = 1; i <= gpGlobals->maxClients; i++ )

	{
		CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
		if ( pPlayer )
			return pPlayer;
	}

	return NULL;
}

//TDT - Information: This is a new function designed to get the nearest player to a player that called the command, this is used for our respawn where killed code to try and respawn at a near-by player.
CBasePlayer *UTIL_GetOtherNearestPlayer( const Vector &origin )
{
// End of copied and pasted code.                                    //TDT - Information: See the following Null Pointer line.
	float distToOtherNearest = 128.0f; //TDT - Information: We don't want the OtherNearest player to be the player that called this function.
	CBasePlayer *pOtherNearest = NULL;

	for (int i = 1; i <= gpGlobals->maxClients; i++ )
	{
		CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
		if ( !pPlayer )
			continue;

		float flDist = (pPlayer->GetAbsOrigin() - origin).LengthSqr();
		if ( flDist >= distToOtherNearest )

		{
			pOtherNearest = pPlayer;
			distToOtherNearest = flDist;

		}
	}


	return pOtherNearest;
}

CBasePlayer *UTIL_GetNearestPlayer( const Vector &origin )
{
	float distToNearest = 99999999999999999999999999999999999999.0f;
	CBasePlayer *pNearest = NULL;

	for (int i = 1; i <= gpGlobals->maxClients; i++ )
	{
		CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
		if ( !pPlayer )
			continue;

		float flDist = (pPlayer->GetAbsOrigin() - origin).LengthSqr();
		if ( flDist < distToNearest )

		{
			pNearest = pPlayer;
			distToNearest = flDist;

		}
	}


	return pNearest;
}

CBasePlayer *UTIL_GetNearestVisiblePlayer( CBaseEntity *pLooker, int mask )
{															
	float distToNearest = 99999999999999999999999999999999999999.0f;
	CBasePlayer *pNearest = NULL;

	for (int i = 1; i <= gpGlobals->maxClients; i++ )
	{
		CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
		if ( !pPlayer )
			continue;

		float flDist = (pPlayer->GetAbsOrigin() - pLooker->GetAbsOrigin()).LengthSqr();
		if ( flDist < distToNearest && pLooker->FVisible( pPlayer, mask ) )
		{
			pNearest = pPlayer;
			distToNearest = flDist;
		}	
	}

	return pNearest; 
}
#else
CBasePlayer *UTIL_GetLocalPlayer( void )
{
	if ( gpGlobals->maxClients > 1 )
	{
		if ( developer.GetBool() )
		{
			Assert( !"UTIL_GetLocalPlayer" );
			
#ifdef	DEBUG
			Warning( "UTIL_GetLocalPlayer() called in multiplayer game.\n" );
#endif
		}

		return NULL;
	}

	return UTIL_PlayerByIndex( 1 );
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 733:

[quote]
if (engine->IsDedicatedServer())
	{
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		Assert( !"UTIL_GetListenServerHost" ); 
		Warning( "UTIL_GetListenServerHost() called from a dedicated server or single-player game.\n" ); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\server\util.h

Line 216:

[quote]
// not useable in multiplayer - see UTIL_GetListenServerHost()
CBasePlayer* UTIL_GetLocalPlayer( void );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
// helper functions added for replacing the above 
CBasePlayer *UTIL_GetNearestPlayer( const Vector &origin ); 
CBasePlayer *UTIL_GetNearestVisiblePlayer(CBaseEntity *pLooker, int mask = MASK_SOLID_BRUSHONLY); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

SHARED FILES.
-------------

.\game\shared\achievements_hlx.cpp

Line 129:

[quote]
			CBaseEntity *pOriginalThrower = pGrenade->GetOriginalThrower();
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 133:

[quote]
			// check if player was most recent thrower, but the victim was the original thrower
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			if ( pThrower->IsPlayer() && ( pOriginalThrower == pVictim ) )
#else
if ( ( pPlayer == pThrower ) && ( pOriginalThrower == pVictim ) )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\basecombatweapon_shared.cpp

Line 967:

[quote]
	//Adrian: Oh man again...
#if !defined( CLIENT_DLL ) && (defined( HL2MP ) || defined( PORTAL ) || defined( SDK_DLL ) )
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( GetOwner()->IsPlayer() ) 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
		SetModel( GetViewModel() );
#endif
[/quote]

.\game\shared\baseentity_shared.cpp

Line 1976:

[quote]
bool CBaseEntity::ShouldDrawUnderwaterBulletBubbles()
{
#if defined( HL2_DLL ) && defined( GAME_DLL )
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pPlayer = UTIL_GetNearestVisiblePlayer(this); 
#else
CBaseEntity *pPlayer = ( gpGlobals->maxClients == 1 ) ? UTIL_GetLocalPlayer() : NULL;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\gamemovement.cpp

Line 1834:

[quote]
	// See if we are changing direction a bit
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	currentspeed = sqrt( DotProduct(mv->m_vecVelocity, mv->m_vecVelocity) );
#else
currentspeed = mv->m_vecVelocity.Dot(wishdir);
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\gamerules.cpp

Line 763:

[quote]
	CAmmoDef *pAmmoDef = GetAmmoDef();

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( pAttacker && pAttacker->IsPlayer() )
#else
if ( pAttacker->IsPlayer() )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2_gamerules.cpp

Line 35:

[quote]
BEGIN_NETWORK_TABLE_NOBASE( CHalfLife2, DT_HL2GameRules )
	#ifdef CLIENT_DLL
		#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		RecvPropBool( RECVINFO( m_bMegaPhysgun ) ),
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 39:

[quote]
	#else
		#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		SendPropBool( SENDINFO( m_bMegaPhysgun ) ),
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
	#endif
[/quote]

Line 75:

[quote]
		SendPropDataTable( "hl2_gamerules_data", 0, &REFERENCE_SEND_TABLE( DT_HL2GameRules ), SendProxy_HL2GameRules )
	END_SEND_TABLE()
#endif

#ifndef OBCO_Enable_Fixed_Multiplayer_AI
ConVar  physcannon_mega_enabled( "physcannon_mega_enabled", "0", FCVAR_CHEAT | FCVAR_REPLICATED );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 225:

[quote]
//TDT - Episodic Issues: Here we disable this as it's been moved to hl2mp_gamerules so that calls to darkness mode work.
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
#ifdef HL2_EPISODIC
ConVar  alyx_darkness_force( "alyx_darkness_force", "0", FCVAR_CHEAT | FCVAR_REPLICATED );
#endif // HL2_EPISODIC
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 261:

[quote]
	CHalfLife2::CHalfLife2()
	{
	#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		m_bMegaPhysgun = false;
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1340:

[quote]
	void CHalfLife2::Think( void )
	{
		BaseClass::Think();
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
		if( physcannon_mega_enabled.GetBool() == true )
		{
			m_bMegaPhysgun = true;
		}
		else
		{
			// FIXME: Is there a better place for this?
			m_bMegaPhysgun = ( GlobalEntity_GetState("super_phys_gun") == GLOBAL_ON );
		}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1413:

[quote]
			// came from any player's physcannon. 
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			for (int i = 1; i <= gpGlobals->maxClients; i++ )//
			//AI Patch Removal: CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);
			{
				CBasePlayer *pPlayer = UTIL_PlayerByIndex( i );
				if ( !pPlayer )//AI Patch Removal
					continue;
#else
CBasePlayer *pPlayer = UTIL_PlayerByIndex(1);

			if( pPlayer )
			{
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1543:

[quote]
		collisionGroup1 = COLLISION_GROUP_NPC;
	}

#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	// This is only for the super physcannon
	if ( m_bMegaPhysgun )
	{
		if ( collisionGroup0 == COLLISION_GROUP_INTERACTIVE_DEBRIS && collisionGroup1 == COLLISION_GROUP_PLAYER )
			return false;
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1766:

[quote]
	BaseClass::LevelInitPreEntity();
}

//TDT - Episodic Issues: Here we disable this as it's been moved to hl2mp_gamerules so that calls to darkness mode work.
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
//-----------------------------------------------------------------------------
// Returns whether or not Alyx cares about light levels in order to see.
//-----------------------------------------------------------------------------
bool CHalfLife2::IsAlyxInDarknessMode()
{
#ifdef HL2_EPISODIC
	if ( alyx_darkness_force.GetBool() )
		return true;

	return ( GlobalEntity_GetState( "ep_alyx_darknessmode" ) == GLOBAL_ON );
#else
	return false;
#endif // HL2_EPISODIC
[/quote]

.\game\shared\hl2_gamerules.h

Line 52:

[quote]
private:

#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	// Rules change for the mega physgun
	CNetworkVar( bool, m_bMegaPhysgun );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 81:

[quote]
	virtual float			GetAmmoDamage( CBaseEntity *pAttacker, CBaseEntity *pVictim, int nAmmoType );

#ifndef OBCO_Enable_Fixed_Multiplayer_AI
//TDT - Episodic Issues: Here we disable this as it's been moved to hl2mp_gamerules so that calls to darkness mode work.
	virtual bool			ShouldBurningPropsEmitLight();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 94:

[quote]
	void	NPC_DroppedGrenade( void );
	
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	bool	MegaPhyscannonActive( void ) { return m_bMegaPhysgun;	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
	
//TDT - Episodic Issues: Here we disable this as it's been moved to hl2mp_gamerules so that calls to darkness mode work.
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
	virtual bool IsAlyxInDarknessMode();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\hl2mp_gamerules.cpp

Line 14:

[quote]
#include "ammodef.h"

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#include "hl2_shareddefs.h"
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 239:

[quote]
		g_Teams.AddToTail( pTeam );
	}	
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	InitDefaultAIRelationships();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 958:

[quote]
//TDT - Information: The below is added from hl2_gamerules.cpp and is required.
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		// Prevent the player movement from colliding with spit globs (caused the player to jump on top of globs while in water)
	if ( collisionGroup0 == COLLISION_GROUP_PLAYER_MOVEMENT && collisionGroup1 == HL2COLLISION_GROUP_SPIT )
		return false;

	// HL2 treats movement and tracing against players the same, so just remap here
	if ( collisionGroup0 == COLLISION_GROUP_PLAYER_MOVEMENT )
	{
		collisionGroup0 = COLLISION_GROUP_PLAYER;
	}

	if( collisionGroup1 == COLLISION_GROUP_PLAYER_MOVEMENT )
	{
		collisionGroup1 = COLLISION_GROUP_PLAYER;
	}

	//If collisionGroup0 is not a player then NPC_ACTOR behaves just like an NPC.
	if ( collisionGroup1 == COLLISION_GROUP_NPC_ACTOR && collisionGroup0 != COLLISION_GROUP_PLAYER )
	{
		collisionGroup1 = COLLISION_GROUP_NPC;
	}

	if ( collisionGroup0 == HL2COLLISION_GROUP_COMBINE_BALL )
	{
		if ( collisionGroup1 == HL2COLLISION_GROUP_COMBINE_BALL )
			return false;
	}

	if ( collisionGroup0 == HL2COLLISION_GROUP_COMBINE_BALL && collisionGroup1 == HL2COLLISION_GROUP_COMBINE_BALL_NPC )
		return false;

	if ( ( collisionGroup0 == COLLISION_GROUP_WEAPON ) ||
		( collisionGroup0 == COLLISION_GROUP_PLAYER ) ||
		( collisionGroup0 == COLLISION_GROUP_PROJECTILE ) )
	{
		if ( collisionGroup1 == HL2COLLISION_GROUP_COMBINE_BALL )
			return false;
	}

	if ( collisionGroup0 == COLLISION_GROUP_DEBRIS )
	{
		if ( collisionGroup1 == HL2COLLISION_GROUP_COMBINE_BALL )
			return true;
	}

	if (collisionGroup0 == HL2COLLISION_GROUP_HOUNDEYE && collisionGroup1 == HL2COLLISION_GROUP_HOUNDEYE )
		return false;

	if (collisionGroup0 == HL2COLLISION_GROUP_HOMING_MISSILE && collisionGroup1 == HL2COLLISION_GROUP_HOMING_MISSILE )
		return false;

	if ( collisionGroup1 == HL2COLLISION_GROUP_CROW )
	{
		if ( collisionGroup0 == COLLISION_GROUP_PLAYER || collisionGroup0 == COLLISION_GROUP_NPC ||
			 collisionGroup0 == HL2COLLISION_GROUP_CROW )
			return false;
	}

	if ( ( collisionGroup0 == HL2COLLISION_GROUP_HEADCRAB ) && ( collisionGroup1 == HL2COLLISION_GROUP_HEADCRAB ) )
		return false;

	// striders don't collide with other striders
	if ( collisionGroup0 == HL2COLLISION_GROUP_STRIDER && collisionGroup1 == HL2COLLISION_GROUP_STRIDER )
		return false;

	// gunships don't collide with other gunships
	if ( collisionGroup0 == HL2COLLISION_GROUP_GUNSHIP && collisionGroup1 == HL2COLLISION_GROUP_GUNSHIP )
		return false;

	// weapons and NPCs don't collide
	if ( collisionGroup0 == COLLISION_GROUP_WEAPON && (collisionGroup1 >= HL2COLLISION_GROUP_FIRST_NPC && collisionGroup1 <= HL2COLLISION_GROUP_LAST_NPC ) )
		return false;

	//players don't collide against NPC Actors.
	//I could've done this up where I check if collisionGroup0 is NOT a player but I decided to just
	//do what the other checks are doing in this function for consistency sake.
	if ( collisionGroup1 == COLLISION_GROUP_NPC_ACTOR && collisionGroup0 == COLLISION_GROUP_PLAYER )
		return false;
		
	// In cases where NPCs are playing a script which causes them to interpenetrate while riding on another entity,
	// such as a train or elevator, you need to disable collisions between the actors so the mover can move them.
	if ( collisionGroup0 == COLLISION_GROUP_NPC_SCRIPTED && collisionGroup1 == COLLISION_GROUP_NPC_SCRIPTED )
		return false;

	// Spit doesn't touch other spit
	if ( collisionGroup0 == HL2COLLISION_GROUP_SPIT && collisionGroup1 == HL2COLLISION_GROUP_SPIT )
		return false;
#endif //OBCO_Enable_Fixed_Multiplayer_AI

	return BaseClass::ShouldCollide( collisionGroup0, collisionGroup1 ); 
[/quote]

Line 1099:

[quote]
		def.AddAmmoType("slam",				DMG_BURN,					TRACER_NONE,			0,			0,						5,			0,							0 );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI		
		def.AddAmmoType("AlyxGun",			DMG_BULLET,					TRACER_LINE,			"sk_plr_dmg_alyxgun",		"sk_npc_dmg_alyxgun",		"sk_max_alyxgun",		BULLET_IMPULSE(200, 1225), 0 );
		def.AddAmmoType("SniperRound",		DMG_BULLET | DMG_SNIPER,	TRACER_NONE,			"sk_plr_dmg_sniper_round",	"sk_npc_dmg_sniper_round",	"sk_max_sniper_round",	BULLET_IMPULSE(650, 6000), 0 );
		def.AddAmmoType("SniperPenetratedRound", DMG_BULLET | DMG_SNIPER, TRACER_NONE,			"sk_dmg_sniper_penetrate_plr", "sk_dmg_sniper_penetrate_npc", "sk_max_sniper_round", BULLET_IMPULSE(150, 6000), 0 );
		def.AddAmmoType("Grenade",			DMG_BURN,					TRACER_NONE,			"sk_plr_dmg_grenade",		"sk_npc_dmg_grenade",		"sk_max_grenade",		0, 0);
		def.AddAmmoType("Thumper",			DMG_SONIC,					TRACER_NONE,			10, 10, 2, 0, 0 );
		def.AddAmmoType("Gravity",			DMG_CLUB,					TRACER_NONE,			0,	0, 8, 0, 0 );
		def.AddAmmoType("Battery",			DMG_CLUB,					TRACER_NONE,			NULL, NULL, NULL, 0, 0 );
		def.AddAmmoType("GaussEnergy",		DMG_SHOCK,					TRACER_NONE,			"sk_jeep_gauss_damage",		"sk_jeep_gauss_damage", "sk_max_gauss_round", BULLET_IMPULSE(650, 8000), 0 ); // hit like a 10kg weight at 400 in/s
		def.AddAmmoType("CombineCannon",	DMG_BULLET,					TRACER_LINE,			"sk_npc_dmg_gunship_to_plr", "sk_npc_dmg_gunship", NULL, 1.5 * 750 * 12, 0 ); // hit like a 1.5kg weight at 750 ft/s
		def.AddAmmoType("AirboatGun",		DMG_AIRBOAT,				TRACER_LINE,			"sk_plr_dmg_airboat",		"sk_npc_dmg_airboat",		NULL,					BULLET_IMPULSE(10, 600), 0 );
		def.AddAmmoType("StriderMinigun",	DMG_BULLET,					TRACER_LINE,			5, 15,15, 1.0 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 1.0kg weight at 750 ft/s
		def.AddAmmoType("StriderMinigunDirect",	DMG_BULLET,				TRACER_LINE,			2, 2, 15, 1.0 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 1.0kg weight at 750 ft/s
		def.AddAmmoType("HelicopterGun",	DMG_BULLET,					TRACER_LINE_AND_WHIZ,	"sk_npc_dmg_helicopter_to_plr", "sk_npc_dmg_helicopter",	"sk_max_smg1",	BULLET_IMPULSE(400, 1225), AMMO_FORCE_DROP_IF_CARRIED | AMMO_INTERPRET_PLRDAMAGE_AS_DAMAGE_TO_PLAYER );
#ifdef HL2_EPISODIC
		def.AddAmmoType("Hopwire",			DMG_BLAST,					TRACER_NONE,			"sk_plr_dmg_grenade",		"sk_npc_dmg_grenade",		"sk_max_hopwire",		0, 0);
		def.AddAmmoType("CombineHeavyCannon",	DMG_BULLET,				TRACER_LINE,			40,	40, NULL, 10 * 750 * 12, AMMO_FORCE_DROP_IF_CARRIED ); // hit like a 10 kg weight at 750 ft/s
		def.AddAmmoType("ammo_proto1",			DMG_BULLET,				TRACER_LINE,			0, 0, 10, 0, 0 );
#endif // HL2_EPISODIC
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1498:

[quote]
return pszFormat;
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI

void CHL2MPRules::InitDefaultAIRelationships( void )
{
	int i, j;

	//  Allocate memory for default relationships
	CBaseCombatCharacter::AllocateDefaultRelationships();

	// --------------------------------------------------------------
	// First initialize table so we can report missing relationships
	// --------------------------------------------------------------
	for (i=0;i<NUM_AI_CLASSES;i++)
	{
		for (j=0;j<NUM_AI_CLASSES;j++)
		{
			// By default all relationships are neutral of priority zero
			CBaseCombatCharacter::SetDefaultRelationship( (Class_T)i, (Class_T)j, D_NU, 0 );
		}
	}

	// ------------------------------------------------------------
	//	> CLASS_ANTLION
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_SCANNER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PROTOSNIPER,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_ANTLION,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ANTLION,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_BARNACLE
	//
	//  In this case, the relationship D_HT indicates which characters
	//  the barnacle will try to eat.
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_BARNACLE,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_MANHACK,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_EARTH_FAUNA,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BARNACLE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_BULLSEYE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PLAYER,			D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_ANTLION,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_VORTIGAUNT,		D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PLAYER_ALLY,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSEYE,			CLASS_HACKED_ROLLERMINE,D_NU, 0);

	// ------------------------------------------------------------
	//	> CLASS_BULLSQUID
	// ------------------------------------------------------------
	/*
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_BARNACLE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_BULLSEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_HEADCRAB,			D_HT, 1);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_HOUNDEYE,			D_HT, 1);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_MANHACK,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_BULLSQUID,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
	*/
	// ------------------------------------------------------------
	//	> CLASS_CITIZEN_PASSIVE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PLAYER,			D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_BARNACLE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_BULLSQUID,		D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_COMBINE_HUNTER,	D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_HEADCRAB,			D_FR, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_HOUNDEYE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_MANHACK,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_MISSILE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_VORTIGAUNT,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_ZOMBIE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PROTOSNIPER,		D_NU, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PLAYER_ALLY,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_PASSIVE,	CLASS_HACKED_ROLLERMINE,D_NU, 0);

	// ------------------------------------------------------------
	//	> CLASS_CITIZEN_REBEL
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PLAYER,			D_NU, 0);			
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_BARNACLE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_BULLSQUID,		D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_MISSILE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_SCANNER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_VORTIGAUNT,		D_LI, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PLAYER_ALLY,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CITIZEN_REBEL,		CLASS_HACKED_ROLLERMINE,D_NU, 0);

	// ------------------------------------------------------------
	//	> CLASS_COMBINE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_BARNACLE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_COMBINE,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_COMBINE_GUNSHIP,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_COMBINE_HUNTER,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_COMBINE_GUNSHIP
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,	CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_COMBINE,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_COMBINE_GUNSHIP,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_COMBINE_HUNTER,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,	CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_MISSILE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_GUNSHIP,		CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_COMBINE_HUNTER
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,	CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_COMBINE,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_COMBINE_GUNSHIP,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_COMBINE_HUNTER,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,	CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_COMBINE_HUNTER,		CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_CONSCRIPT
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PLAYER,			D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_BARNACLE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_SCANNER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_VORTIGAUNT,		D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PLAYER_ALLY,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_CONSCRIPT,			CLASS_HACKED_ROLLERMINE,D_NU, 0);
	
	// ------------------------------------------------------------
	//	> CLASS_FLARE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PLAYER,			D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_ANTLION,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_VORTIGAUNT,		D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PLAYER_ALLY,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_FLARE,			CLASS_HACKED_ROLLERMINE,D_NU, 0);

	// ------------------------------------------------------------
	//	> CLASS_HEADCRAB
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_BULLSQUID,		D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HEADCRAB,			CLASS_HACKED_ROLLERMINE,D_FR, 0);

	// ------------------------------------------------------------
	//	> CLASS_HOUNDEYE
	// ------------------------------------------------------------
	/*
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_BULLSQUID,		D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_HEADCRAB,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HOUNDEYE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);
	*/

	// ------------------------------------------------------------
	//	> CLASS_MANHACK
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_HEADCRAB,			D_HT,-1);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,		CLASS_HOUNDEYE,			D_HT,-1);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MANHACK,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_METROPOLICE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,	CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,	CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_METROPOLICE,		CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_MILITARY
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MILITARY,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_MISSILE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_MISSILE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_NONE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PLAYER,			D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_ANTLION,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_BULLSEYE,			D_NU, 0);	
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_CONSCRIPT,		D_NU, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_VORTIGAUNT,		D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PLAYER_ALLY,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_PLAYER_ALLY_VITAL,D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_NONE,				CLASS_HACKED_ROLLERMINE,D_NU, 0);

	// ------------------------------------------------------------
	//	> CLASS_PLAYER
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PLAYER,			D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_BARNACLE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_BULLSEYE,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_CITIZEN_PASSIVE,	D_LI, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_CITIZEN_REBEL,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_COMBINE_GUNSHIP,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_FLARE,			D_NU, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_MILITARY,			D_HT, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_SCANNER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_VORTIGAUNT,		D_LI, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PROTOSNIPER,		D_HT, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PLAYER_ALLY,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER,			CLASS_HACKED_ROLLERMINE,D_LI, 0);

	// ------------------------------------------------------------
	//	> CLASS_PLAYER_ALLY
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PLAYER,			D_LI, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_BARNACLE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_HEADCRAB,			D_FR, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_SCANNER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_VORTIGAUNT,		D_LI, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_ZOMBIE,			D_FR, 1);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PROTOSNIPER,		D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PLAYER_ALLY,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY,			CLASS_HACKED_ROLLERMINE,D_LI, 0);

	// ------------------------------------------------------------
	//	> CLASS_PLAYER_ALLY_VITAL
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PLAYER,			D_LI, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_BARNACLE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_CITIZEN_REBEL,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_COMBINE_GUNSHIP,	D_NU, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_COMBINE_HUNTER,	D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_SCANNER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_VORTIGAUNT,		D_LI, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PROTOSNIPER,		D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PLAYER_ALLY,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PLAYER_ALLY_VITAL,	CLASS_HACKED_ROLLERMINE,D_LI, 0);

	// ------------------------------------------------------------
    //	> CLASS_SCANNER
	// ------------------------------------------------------------	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,		CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_COMBINE,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_COMBINE_GUNSHIP,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_COMBINE_HUNTER,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,		CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_MANHACK,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_METROPOLICE,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_MILITARY,			D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_SCANNER,			D_LI, 0);		
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_STALKER,			D_LI, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PROTOSNIPER,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_SCANNER,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_STALKER
	// ------------------------------------------------------------	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,		CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_STALKER,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_VORTIGAUNT
	// ------------------------------------------------------------	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PLAYER,			D_LI, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_BARNACLE,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,	CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_CITIZEN_PASSIVE,	D_LI, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_CITIZEN_REBEL,	D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,	CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_SCANNER,			D_HT, 0);		
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_VORTIGAUNT,		D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PLAYER_ALLY,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_VORTIGAUNT,		CLASS_HACKED_ROLLERMINE,D_LI, 0);

	// ------------------------------------------------------------
	//	> CLASS_ZOMBIE
	// ------------------------------------------------------------	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,		CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_COMBINE_HUNTER,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_HEADCRAB,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,		CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_MANHACK,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_MILITARY,			D_FR, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_ZOMBIE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_ZOMBIE,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_PROTOSNIPER
	// ------------------------------------------------------------	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PLAYER,			D_HT, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,		CLASS_BULLSQUID,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_COMBINE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,		CLASS_HOUNDEYE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_METROPOLICE,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_MILITARY,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_MISSILE,			D_NU, 5);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_STALKER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_VORTIGAUNT,		D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_PROTOSNIPER,			CLASS_HACKED_ROLLERMINE,D_HT, 0);

	// ------------------------------------------------------------
	//	> CLASS_EARTH_FAUNA
	//
	// Hates pretty much everything equally except other earth fauna.
	// This will make the critter choose the nearest thing as its enemy.
	// ------------------------------------------------------------	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_NONE,				D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PLAYER,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,		CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_CITIZEN_PASSIVE,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_CITIZEN_REBEL,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_COMBINE_GUNSHIP,	D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_COMBINE_HUNTER,	D_HT, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_CONSCRIPT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_FLARE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,		CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_MANHACK,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_MISSILE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_SCANNER,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_STALKER,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_VORTIGAUNT,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_ZOMBIE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PROTOSNIPER,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_EARTH_FAUNA,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PLAYER_ALLY,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_PLAYER_ALLY_VITAL,D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_EARTH_FAUNA,			CLASS_HACKED_ROLLERMINE,D_NU, 0);

	// ------------------------------------------------------------
	//	> CLASS_HACKED_ROLLERMINE
	// ------------------------------------------------------------
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_NONE,				D_NU, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PLAYER,			D_LI, 0);			
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_ANTLION,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_BARNACLE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_BULLSEYE,			D_NU, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_BULLSQUID,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_CITIZEN_PASSIVE,	D_NU, 0);	
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_CITIZEN_REBEL,	D_NU, 0);
    CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_COMBINE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_COMBINE_GUNSHIP,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_COMBINE_HUNTER,	D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_CONSCRIPT,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_FLARE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HEADCRAB,			D_HT, 0);
	//CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HOUNDEYE,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_MANHACK,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_METROPOLICE,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_MILITARY,			D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_MISSILE,			D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_SCANNER,			D_NU, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_STALKER,			D_HT, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_VORTIGAUNT,		D_LI, 0);		
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_ZOMBIE,			D_HT, 1);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PROTOSNIPER,		D_NU, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_EARTH_FAUNA,		D_HT, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PLAYER_ALLY,		D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_PLAYER_ALLY_VITAL,D_LI, 0);
	CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HACKED_ROLLERMINE,D_LI, 0);
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_357.cpp

Line 17:

[quote]
	#include "hl2mp_player.h"

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
    #include "te_effect_dispatch.h"
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 44:

[quote]
	DECLARE_ACTTABLE();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 83:

[quote]
	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_PISTOL,				false },
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 89:

[quote]
IMPLEMENT_ACTTABLE( CWeapon357 );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
void CWeapon357::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
{
	CBasePlayer *pOwner = ToBasePlayer( GetOwner() );




	switch( pEvent->event )
	{
		case EVENT_WEAPON_RELOAD:
			{
				CEffectData data;


				// Emit six spent shells
				for ( int i = 0; i < 6; i++ )
				{
					data.m_vOrigin = pOwner->WorldSpaceCenter() + RandomVector( -4, 4 );
					data.m_vAngles = QAngle( 90, random->RandomInt( 0, 360 ), 0 );
					data.m_nEntIndex = entindex();

					DispatchEffect( "ShellEject", data );
				}

				break;
			}
	}
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 188:

[quote]
	pPlayer->SnapEyeAngles( angles );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), 600, 0.2, GetOwner() );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_ar2.cpp

Line 18:

[quote]
	#include "prop_combine_ball.h"
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
    #include "npc_combines.h"
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 68:

[quote]
	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_AR2,					false },
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_AR2,				false },
#ifndef CLIENT_DLL
[/quote]

Line 153:

[quote]
	UTIL_PrecacheOther( "env_entity_dissolver" );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
    PrecacheMaterial( "effects/strider_muzzle" );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 159:

[quote]
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pOperator - 
//-----------------------------------------------------------------------------
void CWeaponAR2::FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles )
{
	Vector vecShootOrigin, vecShootDir;

	CAI_BaseNPC *npc = pOperator->MyNPCPointer();
	ASSERT( npc != NULL );

	if ( bUseWeaponAngles )
	{
		QAngle	angShootDir;
		GetAttachment( LookupAttachment( "muzzle" ), vecShootOrigin, angShootDir );
		AngleVectors( angShootDir, &vecShootDir );
	}
	else 
	{
		vecShootOrigin = pOperator->Weapon_ShootPosition();
		vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );
	}

	WeaponSoundRealtime( SINGLE_NPC );

	CSoundEnt::InsertSound( SOUND_COMBAT|SOUND_CONTEXT_GUNFIRE, pOperator->GetAbsOrigin(), SOUNDENT_VOLUME_MACHINEGUN, 0.2, pOperator, SOUNDENT_CHANNEL_WEAPON, pOperator->GetEnemy() );

	pOperator->FireBullets( 1, vecShootOrigin, vecShootDir, VECTOR_CONE_PRECALCULATED, MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 2 );

	// NOTENOTE: This is overriden on the client-side
	// pOperator->DoMuzzleFlash();

	m_iClip1 = m_iClip1 - 1;
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponAR2::FireNPCSecondaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles )
{
	WeaponSound( WPN_DOUBLE );

	CNPC_Combine *pSoldier;

	pSoldier = dynamic_cast<CNPC_Combine*>(GetOwner());

	if( !pSoldier )
		return;

	// Fire!
	Vector vecSrc;
	Vector vecAiming;

	if ( bUseWeaponAngles )
	{
		QAngle	angShootDir;
		GetAttachment( LookupAttachment( "muzzle" ), vecSrc, angShootDir );
		AngleVectors( angShootDir, &vecAiming );
	}
	else 
	{
		vecSrc = pSoldier->Weapon_ShootPosition( );
		vecAiming = pSoldier->GetAltFireTarget() - vecSrc;
		VectorNormalize( vecAiming );
	}

	Vector impactPoint = vecSrc + ( vecAiming * MAX_TRACE_LENGTH );

	float flAmmoRatio = 1.0f;
	float flDuration = RemapValClamped( flAmmoRatio, 0.0f, 1.0f, 0.5f, sk_weapon_ar2_alt_fire_duration.GetFloat() );
	float flRadius = RemapValClamped( flAmmoRatio, 0.0f, 1.0f, 4.0f, sk_weapon_ar2_alt_fire_radius.GetFloat() );

	// Fire the bullets
	Vector vecVelocity = vecAiming * 1000.0f;

	// Fire the combine ball
	CreateCombineBall(	vecSrc, 
		vecVelocity, 
		flRadius, 
		sk_weapon_ar2_alt_fire_mass.GetFloat(),
		flDuration,
		pSoldier );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponAR2::Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary )
{
	if ( bSecondary )
	{
		FireNPCSecondaryAttack( pOperator, true );
	}
	else
	{
		// Ensure we have enough rounds in the clip
		m_iClip1++;

		FireNPCPrimaryAttack( pOperator, true );
	}
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pEvent - 
//			*pOperator - 
//-----------------------------------------------------------------------------
void CWeaponAR2::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
{
	switch( pEvent->event )
	{ 
		case EVENT_WEAPON_AR2:
			{
				FireNPCPrimaryAttack( pOperator, false );
			}
			break;

		case EVENT_WEAPON_AR2_ALTFIRE:
			{
				FireNPCSecondaryAttack( pOperator, false );
			}
			break;

		default:
			CBaseCombatWeapon::Operator_HandleAnimEvent( pEvent, pOperator );
			break;
	}
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 378:

[quote]
	// Register a muzzleflash for the AI
	pOwner->DoMuzzleFlash();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	pOwner->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_ar2.h

Line 79:

[quote]
	DECLARE_ACTTABLE();
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	int CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
	void Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary );
	void FireNPCSecondaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles );
	void FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapom_crowbar.cpp

Line 63:

[quote]
	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	{ ACT_MELEE_ATTACK1,	ACT_MELEE_ATTACK_SWING, true }, 
	{ ACT_IDLE,				ACT_IDLE_ANGRY_MELEE,	false }, 
	{ ACT_IDLE_ANGRY,		ACT_IDLE_ANGRY_MELEE,	false }, 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 110:

[quote]
#ifndef CLIENT_DLL
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
 //-----------------------------------------------------------------------------
// Attempt to lead the target (needed because citizens can't hit manhacks with the crowbar!)
//-----------------------------------------------------------------------------
ConVar sk_crowbar_lead_time( "sk_crowbar_lead_time", "0.9" );

int CWeaponCrowbar::WeaponMeleeAttack1Condition( float flDot, float flDist )
{
	// Attempt to lead the target (needed because citizens can't hit manhacks with the crowbar!)
	CAI_BaseNPC *pNPC	= GetOwner()->MyNPCPointer();
	CBaseEntity *pEnemy = pNPC->GetEnemy();
	if (!pEnemy)
		return COND_NONE;

	Vector vecVelocity;
	vecVelocity = pEnemy->GetSmoothedVelocity( );

	// Project where the enemy will be in a little while
	float dt = sk_crowbar_lead_time.GetFloat();
	dt += random->RandomFloat( -0.3f, 0.2f );
	if ( dt < 0.0f )
		dt = 0.0f;

	Vector vecExtrapolatedPos;
	VectorMA( pEnemy->WorldSpaceCenter(), dt, vecVelocity, vecExtrapolatedPos );

	Vector vecDelta;
	VectorSubtract( vecExtrapolatedPos, pNPC->WorldSpaceCenter(), vecDelta );

	if ( fabs( vecDelta.z ) > 70 )
	{
		return COND_TOO_FAR_TO_ATTACK;
	}

	Vector vecForward = pNPC->BodyDirection2D( );
	vecDelta.z = 0.0f;
	float flExtrapolatedDist = Vector2DNormalize( vecDelta.AsVector2D() );
	if ((flDist > 64) && (flExtrapolatedDist > 64))
	{
		return COND_TOO_FAR_TO_ATTACK;
	}

	float flExtrapolatedDot = DotProduct2D( vecDelta.AsVector2D(), vecForward.AsVector2D() );
	if ((flDot < 0.7) && (flExtrapolatedDot < 0.7))
	{
		return COND_NOT_FACING_ATTACK;
	}

	return COND_CAN_MELEE_ATTACK1;
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 172:

[quote]
AngleVectors( GetAbsAngles(), &vecDirection );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBaseEntity *pEnemy = pOperator->MyNPCPointer() ? pOperator->MyNPCPointer()->GetEnemy() : NULL;
	if ( pEnemy )
	{
		Vector vecDelta;
		VectorSubtract( pEnemy->WorldSpaceCenter(), pOperator->Weapon_ShootPosition(), vecDelta );
		VectorNormalize( vecDelta );
		
		Vector2D vecDelta2D = vecDelta.AsVector2D();
		Vector2DNormalize( vecDelta2D );
		if ( DotProduct2D( vecDelta2D, vecDirection.AsVector2D() ) > 0.8f )
		{
			vecDirection = vecDelta;
		}
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_crowbar.h

Line 51:

[quote]
	void		Drop( const Vector &vecVelocity );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	CWeaponCrowbar( const CWeaponCrowbar & ); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 59:

[quote]
virtual void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	virtual int WeaponMeleeAttack1Condition( float flDot, float flDist ); 
#else
int WeaponMeleeAttack1Condition( float flDot, float flDist );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_frag.cpp

Line 63:

[quote]
	bool	Holster( CBaseCombatWeapon *pSwitchingTo = NULL );
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL 
	int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; } 
#endif 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 69:

[quote]
bool	Reload( void );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	bool	ShouldDisplayHUDHint() { return true; } 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 97:

[quote]
acttable_t	CWeaponFrag::m_acttable[] = 
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
{ ACT_RANGE_ATTACK1, ACT_RANGE_ATTACK_SLAM, true }, 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 211:

[quote]
m_flTimeWeaponIdle = FLT_MAX; //NOTE: This is set once the animation has finished up!
#ifdef OBCO_Enable_Fixed_Multiplayer_AI		
		// Make a sound designed to scare snipers back into their holes!
		CBaseCombatCharacter *pOwner = GetOwner();

		if( pOwner )
		{
			Vector vecSrc = pOwner->Weapon_ShootPosition();
			Vector	vecDir;

			AngleVectors( pOwner->EyeAngles(), &vecDir );

			trace_t tr;

			UTIL_TraceLine( vecSrc, vecSrc + vecDir * 1024, MASK_SOLID_BRUSHONLY, pOwner, COLLISION_GROUP_NONE, &tr );

			CSoundEnt::InsertSound( SOUND_DANGER_SNIPERONLY, tr.endpos, 384, 0.2, pOwner );
		}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\hl2mpbase.h

Line 16:

[quote]
#include "hl2mp_weapon_parse.h"
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL 
	#include "AI_BaseNPC.h" 
#endif 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\hl2mpbasebludgeon.h

Line 36:

[quote]
	DECLARE_PREDICTABLE();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL 
int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_MELEE_ATTACK1; } 
#endif 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_pistol.cpp

Line 94:

[quote]
	DECLARE_ACTTABLE();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	#ifndef CLIENT_DLL
	int CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
	#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 157:

[quote]
	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_PISTOL,					false },
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_PISTOL,				false },


	// HL2
	{ ACT_IDLE,						ACT_IDLE_PISTOL,				true },
	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_PISTOL,			true },
	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_PISTOL,		true },
	{ ACT_RELOAD,					ACT_RELOAD_PISTOL,				true },
	{ ACT_WALK_AIM,					ACT_WALK_AIM_PISTOL,			true },
	{ ACT_RUN_AIM,					ACT_RUN_AIM_PISTOL,				true },
	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_PISTOL,true },
	{ ACT_RELOAD_LOW,				ACT_RELOAD_PISTOL_LOW,			false },
	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_PISTOL_LOW,	false },
	{ ACT_COVER_LOW,				ACT_COVER_PISTOL_LOW,			false },
	{ ACT_RANGE_AIM_LOW,			ACT_RANGE_AIM_PISTOL_LOW,		false },
	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_PISTOL,		false },
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 195:

[quote]
m_bFiresUnderwater	= true;
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
void CWeaponPistol::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
{
	switch( pEvent->event )
	{
		case EVENT_WEAPON_PISTOL_FIRE:
		{
			Vector vecShootOrigin, vecShootDir;
			vecShootOrigin = pOperator->Weapon_ShootPosition();

			CAI_BaseNPC *npc = pOperator->MyNPCPointer();
			ASSERT( npc != NULL );

			vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );

			CSoundEnt::InsertSound( SOUND_COMBAT|SOUND_CONTEXT_GUNFIRE, pOperator->GetAbsOrigin(), SOUNDENT_VOLUME_PISTOL, 0.2, pOperator, SOUNDENT_CHANNEL_WEAPON, pOperator->GetEnemy() );

			WeaponSound( SINGLE_NPC );
			pOperator->FireBullets( 1, vecShootOrigin, vecShootDir, VECTOR_CONE_PRECALCULATED, MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 2 );
			pOperator->DoMuzzleFlash();
			m_iClip1 = m_iClip1 - 1;
		}
		break;
		default:
			BaseClass::Operator_HandleAnimEvent( pEvent, pOperator );
			break;
	}
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_rpg.cpp

Line 50:

[quote]
#define APC_MISSILE_DAMAGE	sk_apc_missile_damage.GetFloat()
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
extern int g_interactionPlayerLaunchedRPG;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 135:

[quote]
	DEFINE_FIELD( m_flDamage,				FIELD_FLOAT ),
	
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	DEFINE_FIELD( m_bCreateDangerSounds,	FIELD_BOOLEAN ),
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 159:

[quote]
	m_hRocketTrail = NULL;
	
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	m_bCreateDangerSounds = false; //
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 202:

[quote]
	SetNextThink( gpGlobals->curtime + 0.3f );
	
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	SetDamage( EXPLOSION_DAMAGE );
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 379:

[quote]
void CMissile::DoExplosion( void )
{
	// Explode
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	ExplosionCreate( GetAbsOrigin(), GetAbsAngles(), GetOwnerEntity(), GetDamage(), CMissile::EXPLOSION_RADIUS,
	#else
	ExplosionCreate( GetAbsOrigin(), GetAbsAngles(), GetOwnerEntity(), GetDamage(), GetDamage() * 2,
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 435:

[quote]
	// Don't touch triggers (but DO hit weapons)
	if ( pOther->IsSolidFlagSet(FSOLID_TRIGGER|FSOLID_VOLUME_CONTENTS) && pOther->GetCollisionGroup() != COLLISION_GROUP_WEAPON )
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	{
		// Some NPCs are triggers that can take damage (like antlion grubs). We should hit them.
		if ( ( pOther->m_takedamage == DAMAGE_NO ) || ( pOther->m_takedamage == DAMAGE_EVENTS_ONLY ) )
			return;
	}
	#else
	return;
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 502:

[quote]
		CBasePlayer *pPlayer = ToBasePlayer( m_hOwner->GetOwner() );

		#ifdef OBCO_Enable_Fixed_Multiplayer_AI
		if ( pPlayer )
		{
			color32 white = { 255,225,205,64 };
			UTIL_ScreenFade( pPlayer, white, 0.1f, 0.0f, FFADE_IN );
		}
		#else
		color32 white = { 255,225,205,64 };
		UTIL_ScreenFade( pPlayer, white, 0.1f, 0.0f, FFADE_IN );
		#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 622:

[quote]
			flBestDist	= dotDist;
		}
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
if( flBestDist <= ( GetAbsVelocity().Length() * 2.5f ) && FVisible( pBestDot->GetAbsOrigin() ) )
	{
		// Scare targets
		CSoundEnt::InsertSound( SOUND_DANGER, pBestDot->GetAbsOrigin(), CMissile::EXPLOSION_RADIUS, 0.2f, pBestDot, SOUNDENT_CHANNEL_REPEATED_DANGER, NULL ); //
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 652:

[quote]
	float flDist = VectorNormalize( vTargetDir );

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
if( pLaserDot->GetTargetEntity() != NULL && flDist <= 240.0f ) //
	{
		// Prevent the missile circling the Strider like a Halo in ep1_c17_06. If the missile gets within 20
		// feet of a Strider, tighten up the turn speed of the missile so it can break the halo and strike. (sjb 4/27/2006)
		if( pLaserDot->GetTargetEntity()->ClassMatches( "npc_strider" ) ) //
		{
			flHomingSpeed *= 1.75f;
		}
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 702:

[quote]
	// Think as soon as possible
	SetNextThink( gpGlobals->curtime );

	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( m_bCreateDangerSounds == true )
	{
		trace_t tr;
		UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + GetAbsVelocity() * 0.5, MASK_SOLID, this, COLLISION_GROUP_NONE, &tr );

		CSoundEnt::InsertSound( SOUND_DANGER, tr.endpos, 100, 0.2, this, SOUNDENT_CHANNEL_REPEATED_DANGER );
	}
	#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 739:

[quote]
return pMissile;
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CUtlVector<CMissile::CustomDetonator_t> CMissile::gm_CustomDetonators;

void CMissile::AddCustomDetonator( CBaseEntity *pEntity, float radius, float height )
{
	int i = gm_CustomDetonators.AddToTail();
	gm_CustomDetonators[i].hEntity = pEntity;
	gm_CustomDetonators[i].radiusSq = Square( radius );
	gm_CustomDetonators[i].halfHeight = height * 0.5f;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void CMissile::RemoveCustomDetonator( CBaseEntity *pEntity )
{
	for ( int i = 0; i < gm_CustomDetonators.Count(); i++ )
	{
		if ( gm_CustomDetonators[i].hEntity == pEntity )
		{
			gm_CustomDetonators.FastRemove( i );
			break;
		}
	}
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 963:

[quote]
	DEFINE_THINKFUNC( ExplodeThink ),
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
DEFINE_THINKFUNC( APCSeekThink ),
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1011:

[quote]
	m_flLastHomingSpeed = APC_HOMING_SPEED;
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CreateDangerSounds( true );


	if( g_pGameRules->GetAutoAimMode() == AUTOAIM_ON_CONSOLE )
	{
		AddFlag( FL_AIMTARGET );
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1093:

[quote]
 	RemoveSolidFlags( FSOLID_NOT_SOLID );
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	SetThink( &CAPCMissile::APCSeekThink );
#else
SetThink( &CAPCMissile::SeekThink );
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 1102:

[quote]
SetNextThink( gpGlobals->curtime );
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
void CAPCMissile::APCSeekThink( void )
{
	BaseClass::SeekThink();

	bool bFoundDot = false;

	//If we can't find a dot to follow around then just send me wherever I'm facing so I can blow up in peace.
	for( CLaserDot *pEnt = GetLaserDotList(); pEnt != NULL; pEnt = pEnt->m_pNext )
	{
		if ( !pEnt->IsOn() )
			continue;

		if ( pEnt->GetOwnerEntity() != GetOwnerEntity() )
			continue;

		bFoundDot = true;
	}

	if ( bFoundDot == false )
	{
		Vector	vDir	= GetAbsVelocity();
		VectorNormalize ( vDir );

		SetAbsVelocity( vDir * 800 );

		SetThink( NULL );
	}
}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1466:

[quote]
	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_RPG,					false },

#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	{ ACT_IDLE_RELAXED,				ACT_IDLE_RPG_RELAXED,			true }, //
	{ ACT_IDLE_STIMULATED,			ACT_IDLE_ANGRY_RPG,				true }, //
	{ ACT_IDLE_AGITATED,			ACT_IDLE_ANGRY_RPG,				true }, //

	{ ACT_IDLE,						ACT_IDLE_RPG,					true }, //
	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_RPG,				true }, //
	{ ACT_WALK,						ACT_WALK_RPG,					true }, //
	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RPG,			true }, //
	{ ACT_RUN,						ACT_RUN_RPG,					true }, //
	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RPG,				true }, //
	{ ACT_COVER_LOW,				ACT_COVER_LOW_RPG,				true }, //
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1492:

[quote]
	m_bGuiding = false;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
m_hMissile = NULL;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1558:

[quote]
	StartGuiding();
		}
	}
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pEvent - 
//			*pOperator - 
//-----------------------------------------------------------------------------

void CWeaponRPG::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
{
	switch( pEvent->event )
	{
		case EVENT_WEAPON_SMG1:
		{
			Msg("RPG firing event\n");
			if ( m_hMissile != NULL )
			{
				Msg("Aborted\n");
				return;
			}

			Vector	muzzlePoint;
			QAngle	vecAngles;

			muzzlePoint = GetOwner()->Weapon_ShootPosition();

			CAI_BaseNPC *npc = pOperator->MyNPCPointer();
			ASSERT( npc != NULL );

			Vector vecShootDir = npc->GetActualShootTrajectory( muzzlePoint );

			// look for a better launch location
			Vector altLaunchPoint;
			if (GetAttachment( "missile", altLaunchPoint ))
			{
				// check to see if it's relativly free
				trace_t tr;
				AI_TraceHull( altLaunchPoint, altLaunchPoint + vecShootDir * (10.0f*12.0f), Vector( -24, -24, -24 ), Vector( 24, 24, 24 ), MASK_NPCSOLID, NULL, &tr );

				if( tr.fraction == 1.0)
				{
					muzzlePoint = altLaunchPoint;
			}
			}
			VectorAngles( vecShootDir, vecAngles );

			CMissile *pMissile = CMissile::Create( muzzlePoint, vecAngles, GetOwner()->edict() );
			pMissile->m_hOwner = this;

		// NPCs always get a grace period
			pMissile->SetGracePeriod( 0.5 );

			pOperator->DoMuzzleFlash();

			WeaponSound( SINGLE_NPC );

			// Make sure our laserdot is off
			m_bGuiding = false;

			if ( m_hLaserDot )
			{
				m_hLaserDot->TurnOff();
			}
		}
		break;

		default:
			Msg("Some other RPG event\n");
			BaseClass::Operator_HandleAnimEvent( pEvent, pOperator );
			break;
	}
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1713:

[quote]
m_hMissile = pMissile;
	
#ifdef OBCO_Enable_Fixed_Multiplayer_AI

		// Register a muzzleflash for the AI
	pOwner->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );

	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), 1000, 0.2, GetOwner(), SOUNDENT_CHANNEL_WEAPON );

	// Check to see if we should trigger any RPG firing triggers
	int iCount = g_hWeaponFireTriggers.Count();
	for ( int i = 0; i < iCount; i++ )
	{
		if ( g_hWeaponFireTriggers[i]->IsTouching( pOwner ) )
		{
			if ( FClassnameIs( g_hWeaponFireTriggers[i], "trigger_rpgfire" ) )
			{
				g_hWeaponFireTriggers[i]->ActivateMultiTrigger( pOwner );
			}
		}
	}

	CAI_BaseNPC **ppAIs = g_AI_Manager.AccessAIs();
	int nAIs = g_AI_Manager.NumAIs();

	string_t iszStriderClassname = AllocPooledString( "npc_strider" );

	for ( int i = 0; i < nAIs; i++ )
	{
		if( ppAIs[ i ]->m_iClassname == iszStriderClassname )
		{
			ppAIs[ i ]->DispatchInteraction( g_interactionPlayerLaunchedRPG, NULL, pMissile );
		}
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1832:

[quote]
// Supress our guiding effects if we're lowered
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	if ( GetIdealActivity() == ACT_VM_IDLE_LOWERED || GetIdealActivity() == ACT_VM_RELOAD )
#else
	if ( GetIdealActivity() == ACT_VM_IDLE_LOWERED )
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1852:

[quote]
		StopGuiding();
	}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI	
	if ( pPlayer->m_afButtonPressed & IN_ATTACK2 )
	{
		ToggleGuiding();
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1878:

[quote]
return vec3_origin;
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1887:

[quote]
void CWeaponRPG::UpdateNPCLaserPosition( const Vector &vecTarget )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
CreateLaserPointer();
	// Turn the laserdot on
	m_bGuiding = true;
	m_hLaserDot->TurnOn();

	Vector muzzlePoint = GetOwner()->Weapon_ShootPosition();
	Vector vecDir = (vecTarget - muzzlePoint);
	VectorNormalize( vecDir );
	vecDir = muzzlePoint + ( vecDir * MAX_TRACE_LENGTH );
	UpdateLaserPosition( muzzlePoint, vecDir );

	SetNPCLaserPosition( vecTarget );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1910:

[quote]
void CWeaponRPG::SetNPCLaserPosition( const Vector &vecTarget ) 
{ 
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
m_vecLaserDot = vecTarget; //
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1920:

[quote]
const Vector &CWeaponRPG::GetNPCLaserPosition( void )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	return m_vecLaserDot;
#else
return vec3_origin;
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 1927:

[quote]
}

#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#endif //
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 2153:

[quote]
return true;
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool CWeaponRPG::WeaponLOSCondition( const Vector &ownerPos, const Vector &targetPos, bool bSetConditions )
{
	bool bResult = BaseClass::WeaponLOSCondition( ownerPos, targetPos, bSetConditions );

	if( bResult )
	{
		CAI_BaseNPC* npcOwner = GetOwner()->MyNPCPointer();

		if( npcOwner )
		{
			trace_t tr;

			Vector vecRelativeShootPosition;
			VectorSubtract( npcOwner->Weapon_ShootPosition(), npcOwner->GetAbsOrigin(), vecRelativeShootPosition );
			Vector vecMuzzle = ownerPos + vecRelativeShootPosition;
			Vector vecShootDir = npcOwner->GetActualShootTrajectory( vecMuzzle );

			// Make sure I have a good 10 feet of wide clearance in front, or I'll blow my teeth out.
			AI_TraceHull( vecMuzzle, vecMuzzle + vecShootDir * (10.0f*12.0f), Vector( -24, -24, -24 ), Vector( 24, 24, 24 ), MASK_NPCSOLID, NULL, &tr );

			if( tr.fraction != 1.0f )
			bResult = false;
		}
	}
	return bResult;
}

//-----------------------------------------------------------------------------
// Purpose: 
// Input  : flDot - 
//			flDist - 
// Output : int
//-----------------------------------------------------------------------------
int CWeaponRPG::WeaponRangeAttack1Condition( float flDot, float flDist )
{
	if ( m_hMissile != NULL )
		return 0;

	// Ignore vertical distance when doing our RPG distance calculations
	CAI_BaseNPC *pNPC = GetOwner()->MyNPCPointer();
	if ( pNPC )
	{
		CBaseEntity *pEnemy = pNPC->GetEnemy();
		Vector vecToTarget = (pEnemy->GetAbsOrigin() - pNPC->GetAbsOrigin());
		vecToTarget.z = 0;
		flDist = vecToTarget.Length();
	}

	if ( flDist < min( m_fMinRange1, m_fMinRange2 ) )
		return COND_TOO_CLOSE_TO_ATTACK;

	if ( m_flNextPrimaryAttack > gpGlobals->curtime )
		return 0;

	// See if there's anyone in the way!
	CAI_BaseNPC *pOwner = GetOwner()->MyNPCPointer();
	ASSERT( pOwner != NULL );

	if( pOwner )
	{
		// Make sure I don't shoot the world!
		trace_t tr;

	Vector vecMuzzle = pOwner->Weapon_ShootPosition();
		Vector vecShootDir = pOwner->GetActualShootTrajectory( vecMuzzle );

		// Make sure I have a good 10 feet of wide clearance in front, or I'll blow my teeth out.
		AI_TraceHull( vecMuzzle, vecMuzzle + vecShootDir * (10.0f*12.0f), Vector( -24, -24, -24 ), Vector( 24, 24, 24 ), MASK_NPCSOLID, NULL, &tr );

		if( tr.fraction != 1.0 )
		{
			return COND_WEAPON_SIGHT_OCCLUDED;
		}
	}

	return COND_CAN_RANGE_ATTACK1;
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_rpg.h

Line 40:

[quote]
	DECLARE_CLASS( CMissile, CBaseCombatCharacter );

public:
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
static const int EXPLOSION_RADIUS = 200; 
	static const int EXPLOSION_DAMAGE = 200; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 76:

[quote]
	static CMissile *Create( const Vector &vecOrigin, const QAngle &vecAngles, edict_t *pentOwner );
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	void CreateDangerSounds( bool bState ){ m_bCreateDangerSounds = bState; } 
	
	static void AddCustomDetonator( CBaseEntity *pEntity, float radius, float height = -1 );
	static void RemoveCustomDetonator( CBaseEntity *pEntity );
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 98:

[quote]
	float					m_flDamage;
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	struct CustomDetonator_t 
	{ 
		EHANDLE hEntity; 
		float radiusSq; 
		float halfHeight; 
	}; 

	static CUtlVector<CustomDetonator_t> gm_CustomDetonators; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 111:

[quote]
private:
	float					m_flGracePeriodEndsAt;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	bool					m_bCreateDangerSounds; 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 150:

[quote]
	void	SetGuidanceHint( const char *pHintName );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	void	APCSeekThink( void ); 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 227:

[quote]
	float	GetMaxRestTime() { return 4.0; }
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	#ifndef CLIENT_DLL 
	bool	WeaponLOSCondition( const Vector &ownerPos, const Vector &targetPos, bool bSetConditions ); 
	int		WeaponRangeAttack1Condition( float flDot, float flDist ); 

	void	Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator ); 
#endif 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 250:

[quote]
	Vector	GetLaserPosition( void );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	#ifndef CLIENT_DLL 

	// NPC RPG users cheat and directly set the laser pointer's origin
	
	int		CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; } 
#endif 
	virtual const Vector& GetBulletSpread( void ) 
	{ 
		static Vector cone = VECTOR_CONE_3DEGREES; 
		return cone; 
	} 
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_shotgun.cpp

Line 33:

[quote]
	DECLARE_PREDICTABLE();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	int CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
	void Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary );
	void FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 138:

[quote]
{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SHOTGUN,					false },
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SHOTGUN,				false },

	// HL2
	{ ACT_IDLE,						ACT_IDLE_SMG1,					true },	// FIXME: hook to shotgun unique

	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_SHOTGUN,			true },
	{ ACT_RELOAD,					ACT_RELOAD_SHOTGUN,					false },
	{ ACT_WALK,						ACT_WALK_RIFLE,						true },
	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_SHOTGUN,				true },

// Readiness activities (not aiming)
	{ ACT_IDLE_RELAXED,				ACT_IDLE_SHOTGUN_RELAXED,		false },//never aims
	{ ACT_IDLE_STIMULATED,			ACT_IDLE_SHOTGUN_STIMULATED,	false },
	{ ACT_IDLE_AGITATED,			ACT_IDLE_SHOTGUN_AGITATED,		false },//always aims

	{ ACT_WALK_RELAXED,				ACT_WALK_RIFLE_RELAXED,			false },//never aims
	{ ACT_WALK_STIMULATED,			ACT_WALK_RIFLE_STIMULATED,		false },
	{ ACT_WALK_AGITATED,			ACT_WALK_AIM_RIFLE,				false },//always aims

	{ ACT_RUN_RELAXED,				ACT_RUN_RIFLE_RELAXED,			false },//never aims
	{ ACT_RUN_STIMULATED,			ACT_RUN_RIFLE_STIMULATED,		false },
	{ ACT_RUN_AGITATED,				ACT_RUN_AIM_RIFLE,				false },//always aims



// Readiness activities (aiming)
	{ ACT_IDLE_AIM_RELAXED,			ACT_IDLE_SMG1_RELAXED,			false },//never aims	
	{ ACT_IDLE_AIM_STIMULATED,		ACT_IDLE_AIM_RIFLE_STIMULATED,	false },
	{ ACT_IDLE_AIM_AGITATED,		ACT_IDLE_ANGRY_SMG1,			false },//always aims



	{ ACT_WALK_AIM_RELAXED,			ACT_WALK_RIFLE_RELAXED,			false },//never aims
	{ ACT_WALK_AIM_STIMULATED,		ACT_WALK_AIM_RIFLE_STIMULATED,	false },
	{ ACT_WALK_AIM_AGITATED,		ACT_WALK_AIM_RIFLE,				false },//always aims



	{ ACT_RUN_AIM_RELAXED,			ACT_RUN_RIFLE_RELAXED,			false },//never aims
	{ ACT_RUN_AIM_STIMULATED,		ACT_RUN_AIM_RIFLE_STIMULATED,	false },
	{ ACT_RUN_AIM_AGITATED,			ACT_RUN_AIM_RIFLE,				false },//always aims
//End readiness activities



	{ ACT_WALK_AIM,					ACT_WALK_AIM_SHOTGUN,				true },
	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RIFLE,				true },
	{ ACT_WALK_CROUCH_AIM,			ACT_WALK_CROUCH_AIM_RIFLE,			true },
	{ ACT_RUN,						ACT_RUN_RIFLE,						true },
	{ ACT_RUN_AIM,					ACT_RUN_AIM_SHOTGUN,				true },
	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RIFLE,				true },
	{ ACT_RUN_CROUCH_AIM,			ACT_RUN_CROUCH_AIM_RIFLE,			true },
	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_SHOTGUN,	true },
	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_SHOTGUN_LOW,		true },
	{ ACT_RELOAD_LOW,				ACT_RELOAD_SHOTGUN_LOW,				false },
	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_SHOTGUN,			false },
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 199:

[quote]
IMPLEMENT_ACTTABLE(CWeaponShotgun);
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pOperator - 
//-----------------------------------------------------------------------------
void CWeaponShotgun::FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, bool bUseWeaponAngles )
{
	Vector vecShootOrigin, vecShootDir;
	CAI_BaseNPC *npc = pOperator->MyNPCPointer();
	ASSERT( npc != NULL );
	WeaponSound( SINGLE_NPC );
	pOperator->DoMuzzleFlash();
	m_iClip1 = m_iClip1 - 1;

	if ( bUseWeaponAngles )
	{
		QAngle	angShootDir;
		GetAttachment( LookupAttachment( "muzzle" ), vecShootOrigin, angShootDir );
		AngleVectors( angShootDir, &vecShootDir );
	}
	else 
	{
		vecShootOrigin = pOperator->Weapon_ShootPosition();
		vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );
	}

	pOperator->FireBullets( 8, vecShootOrigin, vecShootDir, GetBulletSpread(), MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 0 );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponShotgun::Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary )
{
	// Ensure we have enough rounds in the clip
	m_iClip1++;

	FireNPCPrimaryAttack( pOperator, true );
}

//-----------------------------------------------------------------------------
// Purpose:
// Input  :
// Output :
//-----------------------------------------------------------------------------
void CWeaponShotgun::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
{
	switch( pEvent->event )
	{
		case EVENT_WEAPON_SHOTGUN_FIRE:
		{
			FireNPCPrimaryAttack( pOperator, false );
		}
		break;

		default:
			CBaseCombatWeapon::Operator_HandleAnimEvent( pEvent, pOperator );
			break;
	}
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 472:

[quote]
	// Fire the bullets, and force the first shot to be perfectly accuracy
	pPlayer->FireBullets( info );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	// DM: Hellow? NPCs... look here! I'm shooting!
	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), SOUNDENT_VOLUME_SHOTGUN, 0.2 );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 535:

[quote]
	pPlayer->ViewPunch( QAngle(SharedRandomFloat( "shotgunsax", -5, 5 ),0,0) );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	// DM: Hellow? NPCs... look here! I'm shooting!
	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
	CSoundEnt::InsertSound( SOUND_COMBAT, GetAbsOrigin(), SOUNDENT_VOLUME_SHOTGUN, 0.2 );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_smg1.cpp

Line 66:

[quote]
	DECLARE_ACTTABLE();
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	int CapabilitiesGet( void ) { return bits_CAP_WEAPON_RANGE_ATTACK1; }
	void Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator );
	void FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, Vector &vecShootOrigin, Vector &vecShootDir );
	void Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 110:

[quote]
{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_SMG1,					false },
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	{ ACT_RANGE_ATTACK1,				ACT_RANGE_ATTACK_SMG1,					false },

	// HL2
	{ ACT_RANGE_ATTACK1,			ACT_RANGE_ATTACK_SMG1,			true },
	{ ACT_RELOAD,					ACT_RELOAD_SMG1,				true },
	{ ACT_IDLE,						ACT_IDLE_SMG1,					true },
	{ ACT_IDLE_ANGRY,				ACT_IDLE_ANGRY_SMG1,			true },

	{ ACT_WALK,						ACT_WALK_RIFLE,					true },
	{ ACT_WALK_AIM,					ACT_WALK_AIM_RIFLE,				true  },
	
// Readiness activities (not aiming)
	{ ACT_IDLE_RELAXED,				ACT_IDLE_SMG1_RELAXED,			false },//never aims
	{ ACT_IDLE_STIMULATED,			ACT_IDLE_SMG1_STIMULATED,		false },
	{ ACT_IDLE_AGITATED,			ACT_IDLE_ANGRY_SMG1,			false },//always aims

	{ ACT_WALK_RELAXED,				ACT_WALK_RIFLE_RELAXED,			false },//never aims
	{ ACT_WALK_STIMULATED,			ACT_WALK_RIFLE_STIMULATED,		false },
	{ ACT_WALK_AGITATED,			ACT_WALK_AIM_RIFLE,				false },//always aims

	{ ACT_RUN_RELAXED,				ACT_RUN_RIFLE_RELAXED,			false },//never aims
	{ ACT_RUN_STIMULATED,			ACT_RUN_RIFLE_STIMULATED,		false },
	{ ACT_RUN_AGITATED,				ACT_RUN_AIM_RIFLE,				false },//always aims


// Readiness activities (aiming)
	{ ACT_IDLE_AIM_RELAXED,			ACT_IDLE_SMG1_RELAXED,			false },//never aims	
	{ ACT_IDLE_AIM_STIMULATED,		ACT_IDLE_AIM_RIFLE_STIMULATED,	false },
	{ ACT_IDLE_AIM_AGITATED,		ACT_IDLE_ANGRY_SMG1,			false },//always aims



	{ ACT_WALK_AIM_RELAXED,			ACT_WALK_RIFLE_RELAXED,			false },//never aims
	{ ACT_WALK_AIM_STIMULATED,		ACT_WALK_AIM_RIFLE_STIMULATED,	false },
	{ ACT_WALK_AIM_AGITATED,		ACT_WALK_AIM_RIFLE,				false },//always aims



	{ ACT_RUN_AIM_RELAXED,			ACT_RUN_RIFLE_RELAXED,			false },//never aims
	{ ACT_RUN_AIM_STIMULATED,		ACT_RUN_AIM_RIFLE_STIMULATED,	false },
	{ ACT_RUN_AIM_AGITATED,			ACT_RUN_AIM_RIFLE,				false },//always aims
//End readiness activities



	{ ACT_WALK_AIM,					ACT_WALK_AIM_RIFLE,				true },
	{ ACT_WALK_CROUCH,				ACT_WALK_CROUCH_RIFLE,			true },
	{ ACT_WALK_CROUCH_AIM,			ACT_WALK_CROUCH_AIM_RIFLE,		true },
	{ ACT_RUN,						ACT_RUN_RIFLE,					true },
	{ ACT_RUN_AIM,					ACT_RUN_AIM_RIFLE,				true },
	{ ACT_RUN_CROUCH,				ACT_RUN_CROUCH_RIFLE,			true },
	{ ACT_RUN_CROUCH_AIM,			ACT_RUN_CROUCH_AIM_RIFLE,		true },
	{ ACT_GESTURE_RANGE_ATTACK1,	ACT_GESTURE_RANGE_ATTACK_SMG1,	true },
	{ ACT_RANGE_ATTACK1_LOW,		ACT_RANGE_ATTACK_SMG1_LOW,		true },
	{ ACT_COVER_LOW,				ACT_COVER_SMG1_LOW,				false },
	{ ACT_RANGE_AIM_LOW,			ACT_RANGE_AIM_SMG1_LOW,			false },
	{ ACT_RELOAD_LOW,				ACT_RELOAD_SMG1_LOW,			false },
	{ ACT_GESTURE_RELOAD,			ACT_GESTURE_RELOAD_SMG1,		true },
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 181:

[quote]
	m_fMaxRange1		= 1400;
}
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponSMG1::FireNPCPrimaryAttack( CBaseCombatCharacter *pOperator, Vector &vecShootOrigin, Vector &vecShootDir )
{
	// FIXME: use the returned number of bullets to account for >10hz firerate
	WeaponSoundRealtime( SINGLE_NPC );

	CSoundEnt::InsertSound( SOUND_COMBAT|SOUND_CONTEXT_GUNFIRE, pOperator->GetAbsOrigin(), SOUNDENT_VOLUME_MACHINEGUN, 0.2, pOperator, SOUNDENT_CHANNEL_WEAPON, pOperator->GetEnemy() );
	pOperator->FireBullets( 1, vecShootOrigin, vecShootDir, VECTOR_CONE_PRECALCULATED,
		MAX_TRACE_LENGTH, m_iPrimaryAmmoType, 2, entindex(), 0 );

	pOperator->DoMuzzleFlash();
	m_iClip1 = m_iClip1 - 1;
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponSMG1::Operator_ForceNPCFire( CBaseCombatCharacter *pOperator, bool bSecondary )
{
	// Ensure we have enough rounds in the clip
	m_iClip1++;

	Vector vecShootOrigin, vecShootDir;
	QAngle	angShootDir;
	GetAttachment( LookupAttachment( "muzzle" ), vecShootOrigin, angShootDir );
	AngleVectors( angShootDir, &vecShootDir );
	FireNPCPrimaryAttack( pOperator, vecShootOrigin, vecShootDir );
}

//-----------------------------------------------------------------------------
// Purpose: 
//-----------------------------------------------------------------------------
void CWeaponSMG1::Operator_HandleAnimEvent( animevent_t *pEvent, CBaseCombatCharacter *pOperator )
{
	switch( pEvent->event )
	{
	case EVENT_WEAPON_SMG1:
		{
			Vector vecShootOrigin, vecShootDir;
			QAngle angDiscard;

			// Support old style attachment point firing
			if ((pEvent->options == NULL) || (pEvent->options[0] == '\0') || (!pOperator->GetAttachment(pEvent->options, vecShootOrigin, angDiscard)))
			{
				vecShootOrigin = pOperator->Weapon_ShootPosition();
			}

			CAI_BaseNPC *npc = pOperator->MyNPCPointer();
			ASSERT( npc != NULL );
			vecShootDir = npc->GetActualShootTrajectory( vecShootOrigin );

			FireNPCPrimaryAttack( pOperator, vecShootOrigin, vecShootDir );
		}
		break;

		/*//FIXME: Re-enable
		case EVENT_WEAPON_AR2_GRENADE:
		{
		CAI_BaseNPC *npc = pOperator->MyNPCPointer();

		Vector vecShootOrigin, vecShootDir;
		vecShootOrigin = pOperator->Weapon_ShootPosition();
		vecShootDir = npc->GetShootEnemyDir( vecShootOrigin );

		Vector vecThrow = m_vecTossVelocity;

		CGrenadeAR2 *pGrenade = (CGrenadeAR2*)Create( "grenade_ar2", vecShootOrigin, vec3_angle, npc );
		pGrenade->SetAbsVelocity( vecThrow );
		pGrenade->SetLocalAngularVelocity( QAngle( 0, 400, 0 ) );
		pGrenade->SetMoveType( MOVETYPE_FLYGRAVITY ); 
		pGrenade->m_hOwner			= npc;
		pGrenade->m_pMyWeaponAR2	= this;
		pGrenade->SetDamage(sk_npc_dmg_ar2_grenade.GetFloat());

		// FIXME: arrgg ,this is hard coded into the weapon???
		m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.

		m_iClip2--;
		}
		break;
		*/

	default:
		BaseClass::Operator_HandleAnimEvent( pEvent, pOperator );
		break;
	}
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 416:

[quote]
// Can blow up after a short delay (so have time to release mouse button)
	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
#ifndef CLIENT_DLL
	// Register a muzzleflash for the AI.
	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );

	CSoundEnt::InsertSound( SOUND_COMBAT, pPlayer->GetAbsOrigin(), SOUNDENT_VOLUME_MACHINEGUN, 0.2, pPlayer );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\hl2mp\weapon_stunstick.cpp

Line 92:

[quote]
	int			WeaponMeleeAttack1Condition( float flDot, float flDist );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	bool		CanBePickedUpByNPCs( void ) { return false;	}	
#endif //OBCO_Enable_Fixed_Multiplayer_AI	
[/quote]

Line 171:

[quote]
	{ ACT_MP_JUMP,						ACT_HL2MP_JUMP_MELEE,					false },
	#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 365:

[quote]
				CBasePlayer *pPlayer = ToBasePlayer( pHurt );
				#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				CNPC_MetroPolice *pCop = dynamic_cast<CNPC_MetroPolice *>(pOperator); 
				#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 370:

[quote]
	bool bFlashed = false;
				
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
				if ( pCop != NULL && pPlayer != NULL )
				{
					// See if we need to knock out this target
					if ( pCop->ShouldKnockOutTarget( pHurt ) )
					{
						float yawKick = random->RandomFloat( -48, -24 );

						//Kick the player angles
						pPlayer->ViewPunch( QAngle( -16, yawKick, 2 ) );

						color32 white = {255,255,255,255};
						UTIL_ScreenFade( pPlayer, white, 0.2f, 1.0f, FFADE_OUT|FFADE_PURGE|FFADE_STAYOUT );
						bFlashed = true;
						
						pCop->KnockOutTarget( pHurt );

						break;
					}
					else
					{
						// Notify that we've stunned a target
						pCop->StunnedTarget( pHurt );
					}
				}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 515

[quote]
	SetStunState( false );
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
BaseClass::Drop( vecVelocity ); 
#else
#ifndef CLIENT_DLL
	UTIL_Remove( this );
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\particlesystemquery.cpp

Line 578:

[quote]
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer(); //AI Patch Replacment: CBasePlayer *pPlayer = AI_GetSinglePlayer();
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 603:

[quote]
	pPlayer->EyeVectors( pForward, pRight, pUp );
#else
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
	CBasePlayer *pPlayer = UTIL_GetLocalPlayer();	
#else
CBasePlayer *pPlayer = AI_GetSinglePlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\ragdoll_shared.cpp

Line 755:

[quote]
		return true;
	}

#else
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
CBasePlayer *pPlayer = UTIL_GetLocalPlayer();
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

Line 766:

[quote]
	 NDebugOverlay::Line( pRagdoll->GetAbsOrigin(), pRagdoll->GetAbsOrigin() + Vector( 0, 0, 64 ), 0, 255, 0, true, 5 );

		return true;
	}
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
else if( !pPlayer->FInViewCone( pRagdoll ) )
	{
		if ( g_debug_ragdoll_removal.GetBool() )
			 NDebugOverlay::Line( pRagdoll->GetAbsOrigin(), pRagdoll->GetAbsOrigin() + Vector( 0, 0, 64 ), 0, 0, 255, true, 5 );
		
		return true;
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\teamplayroundbased_gamerules.cpp

Line 264:

[quote]
		if ( args.ArgC() == 1 )
		{
			// if no team specified, use player 1's team
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
			iTeam = UTIL_GetLocalPlayer()->GetTeamNumber();	
#else
iTeam = UTIL_PlayerByIndex( 1 )->GetTeamNumber();	
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]

.\game\shared\util_shared.cpp

Line 765:

[quote]
void UTIL_BloodDrips( const Vector &origin, const Vector &direction, int color, int amount )
{
#ifdef OBCO_Enable_Fixed_Multiplayer_AI
IPredictionSystem::SuppressHostEvents( NULL );
#endif //OBCO_Enable_Fixed_Multiplayer_AI

[/quote]

Line 777:

[quote]
if ( g_Language.GetInt() == LANGUAGE_GERMAN && color == BLOOD_COLOR_RED )
		color = 0;
#ifndef OBCO_Enable_Fixed_Multiplayer_AI
if ( g_pGameRules->IsMultiplayer() )
	{
		// scale up blood effect in multiplayer for better visibility
		amount *= 5;
	}
#endif //OBCO_Enable_Fixed_Multiplayer_AI
[/quote]


Episodic Changes You Should Make.
---------------------------------

.\game\client\fx_blood.cpp

Line 478: 
ParticleForBlood_t	bloodCallbacks[] =
{
Comment out the #ifdefs here so that the code looks like:

[quote]
ParticleForBlood_t	bloodCallbacks[] =
{

//TDT - Episodic Issues: If we don't comment out this ifdef (which used to be an if), then the code doesn't compile.
//#ifdef HL2_EPISODIC
	{ BLOOD_COLOR_RED,		"blood_impact_red_01" },
	{ BLOOD_COLOR_GREEN,	"blood_impact_green_01" },
	{ BLOOD_COLOR_YELLOW,	"blood_impact_yellow_01" },
	{ BLOOD_COLOR_ANTLION,		"blood_impact_antlion_01" },		// FIXME: Move to Base HL2
	{ BLOOD_COLOR_ZOMBIE,		"blood_impact_zombie_01" },			// FIXME: Move to Base HL2
	{ BLOOD_COLOR_ANTLION_WORKER,	"blood_impact_antlion_worker_01" },
//#endif // HL2_EPISODIC
};
[/quote]

.\game\client\hl2\hud_locator.cpp

Line 109:
	if( pPlayer->m_HL2Local.m_vecLocatorOrigin == vec3_invalid )
		return false;
		
Should become:

[quote]
#ifdef HL2_EPISODIC
	if( pPlayer->m_HL2Local.m_vecLocatorOrigin == vec3_invalid )
		return false;
#endif //HL2_EPISODIC
[/quote]

.\game\server\ai_behavior_follow.cpp

Line 21:

[quote]
#include "ai_senses.h"

//TDT - Episodic Issues: Here we include the hl2mp gamerules so that calls to darkness mode work.
#include "hl2mp_gamerules.h"
[/quote]

.\game\server\ai_behavior_passenger.cpp

Line 866:

	m_hVehicle->RemovePhysicsChild( GetOuter() );
	
[quote]
//TDT - Episodic Issues: We add in this if def solely for people who DO NOT want episode 2 content.
#ifdef HL2_EPISODIC
	m_hVehicle->RemovePhysicsChild( GetOuter() );
#endif
[/quote]

Line 894:

	// Get physics messages from our attached physics object
	m_hVehicle->AddPhysicsChild( GetOuter() );
	
[quote]
	//TDT - Episodic Issues: We add in this if def solely for people who DO NOT want episode 2 content.
#ifdef HL2_EPISODIC
	// Get physics messages from our attached physics object
	m_hVehicle->AddPhysicsChild( GetOuter() );
#endif
[/quote]

.\game\server\basecombatcharacter.cpp

Line 41

[quote]
#include "saverestoretypes.h"

//TDT - Episodic Issues: Here we include the hl2mp gamerules so that calls to darkness mode work.
#include "hl2mp_gamerules.h"
[/quote]

.\game\server\episodic\weapon_striderbuster.cpp

Line 53:

[quote]
ConVar striderbuster_use_particle_flare( "striderbuster_use_particle_flare", "1" );

#ifdef HL2_EPISODIC //TDT - Episodic Issues: Code can't compile without using an ifdef here.
#define STRIDERBUSTER_FLAG_KNOCKED_OFF_STRIDER		0x00000001 // We were knocked off of a strider after the player attached me.
[/quote]

Line 1178 (End of File):

[quote]
	return false;
}

#endif //HL2_EPISODIC
[/quote]

.\game\server\hl2\npc_alyx_episodic.cpp

Line 40:

[quote]
#include "env_debughistory.h"

//TDT - Episodic Issues: Here we include the hl2mp gamerules so that calls to darkness mode work.
#include "hl2mp_gamerules.h"
[/quote]

.\game\server\hl2\npc_BaseZombie.cpp

Line 51:

[quote]
#include "vehicle_base.h"

//TDT - Episodic Issues: Here we include the hl2mp gamerules so that calls to darkness mode work.
#include "hl2mp_gamerules.h"
[/quote]

.\game\server\hl2\npc_headcrab.cpp

Line 36:

[quote]
#include "decals.h"

//TDT - Episodic Issues: Here we include the hl2mp gamerules so that calls to darkness mode work.
#include "hl2mp_gamerules.h"
[/quote]

.\game\server\hl2\npc_zombine.cpp

Line 38:

[quote]
#include "ai_interactions.h"

//TDT - Episodic Issues: Here we include the hl2mp gamerules so that calls to darkness mode work.
#include "hl2mp_gamerules.h"
[/quote]

.\game\server\physconstraint.cpp

Line 20:

[quote]
#include "physics_prop_ragdoll.h"

//TDT - Episodic Issues: If we don't comment these out, then the code doesn't compile.
//#define HINGE_NOTIFY HL2_EPISODIC
//#if HINGE_NOTIFY
#include "physconstraint_sounds.h"
//#endif
[/quote]

.\game\server\hl2mp\hl2mp_gamerules.cpp

Line 44:

[quote]
	#include "hl2mp_cvars.h"
	
//TDT - Episodic Issues: Here we include the globalstate.h file so that darkness mode will work for GLOBAL_ON state.
#include "globalstate.h"
[/quote]

Line 74:

[quote]
ConVar sv_report_client_settings("sv_report_client_settings", "0", FCVAR_GAMEDLL | FCVAR_NOTIFY );

//TDT - Episodic Issues: Here we add darkness mode so that it now works.
#ifdef HL2_EPISODIC  

ConVar  alyx_darkness_force( "alyx_darkness_force", "0", FCVAR_CHEAT | FCVAR_REPLICATED );

#endif // HL2_EPISODIC
[/quote]

Line 2493:

[quote]
CBaseCombatCharacter::SetDefaultRelationship(CLASS_HACKED_ROLLERMINE,			CLASS_HACKED_ROLLERMINE,D_LI, 0);
}
#endif
#endif //OBCO_Enable_Fixed_Multiplayer_AI

//TDT - Episodic Issues: Here we add darkness mode so that it now works.
#ifndef CLIENT_DLL

//-----------------------------------------------------------------------------
// Returns whether or not Alyx cares about light levels in order to see.
//-----------------------------------------------------------------------------
bool CHL2MPRules::IsAlyxInDarknessMode()
{
#ifdef HL2_EPISODIC

	if ( alyx_darkness_force.GetBool() )
		return true;

	return ( GlobalEntity_GetState( "ep_alyx_darknessmode" ) == GLOBAL_ON );
#else
	return false;
#endif // HL2_EPISODIC
}


//-----------------------------------------------------------------------------
// This takes the long way around to see if a prop should emit a DLIGHT when it
// ignites, to avoid having Alyx-related code in props.cpp.
//-----------------------------------------------------------------------------
bool CHL2MPRules::ShouldBurningPropsEmitLight()
{
#ifdef HL2_EPISODIC

	return IsAlyxInDarknessMode();
#else
	return false;
#endif // HL2_EPISODIC
}

#endif//CLIENT_DLL
[/quote]

.\game\server\hl2mp\hl2mp_gamerules.h

Line 100:

[quote]
	DECLARE_SERVERCLASS_NOBASE(); // This makes datatables able to access our private vars.
	
//TDT - Episodic Issues: Here we add darkness mode so that it now works.
	virtual bool IsAlyxInDarknessMode();
	virtual bool ShouldBurningPropsEmitLight();
[/quote]

.\game\shared\shareddefs.h

Line 452:

[quote]
	BLOOD_COLOR_MECH,

//TDT - Episodic Issues: If we don't comment out this ifdef (which used to be an if), then the code doesn't compile.
//#ifdef HL2_EPISODIC
	BLOOD_COLOR_ANTLION,		// FIXME: Move to Base HL2
	BLOOD_COLOR_ZOMBIE,			// FIXME: Move to Base HL2
	BLOOD_COLOR_ANTLION_WORKER,
//#endif // HL2_EPISODIC
[/quote]

Final Note: There are episodic changes that can be made to func_tank.cpp/.h these are covered in another tutorial in which we tell people how to fix the mounted guns so that they work in HL2MP. The AI and script will compile just fine without these changes, and it means those wishing to have mounted turrets without AI don't have to go through all of this tutorial to find the code they're after.

You finally Reached The End!
----------------------------

If you have followed along, you should now have working AI in your HL2MP modification (if all went well).

 - The Development Team -
 
 </body>
 </html>
